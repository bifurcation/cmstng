#
# X.509 message syntax
#
# ASN.1 source from:
# http://www.trl.ibm.com/projects/xml/xss4j/data/asn1/grammars/x509.asn
#
# Sample captures from:
# http://wiki.wireshark.org/SampleCaptures/
#
from Crypto.PublicKey import RSA
from datetime import datetime
from pyasn1 import error
from pyasn1.codec.der import decoder, encoder
from pyasn1.type import tag,namedtype,namedval,univ,constraint,char,useful
import crypto
import string, base64

# Would be autogenerated from ASN.1 source by a ASN.1 parser
# X.509 spec (rfc2459)

MAX = 64  # XXX ?
rsaEncryption = (1, 2, 840, 113549, 1, 1, 1)
basicConstraints = (2, 5, 29, 19)

class DirectoryString(univ.Choice):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('teletexString', char.TeletexString().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX))),
        namedtype.NamedType('printableString', char.PrintableString().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX))),
        namedtype.NamedType('universalString', char.UniversalString().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX))),
        namedtype.NamedType('utf8String', char.UTF8String().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX))),
        namedtype.NamedType('bmpString', char.BMPString().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX))),
        namedtype.NamedType('ia5String', char.IA5String().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX))) # hm, this should not be here!? XXX
        )

class AttributeValue(DirectoryString): pass

class AttributeType(univ.ObjectIdentifier): pass

class AttributeTypeAndValue(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('type', AttributeType()),
        namedtype.NamedType('value', AttributeValue())
        )

class RelativeDistinguishedName(univ.SetOf):
    componentType = AttributeTypeAndValue()

class RDNSequence(univ.SequenceOf):
    componentType = RelativeDistinguishedName()

class Name(univ.Choice):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('', RDNSequence())
        )
                          
class AlgorithmIdentifier(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('algorithm', univ.ObjectIdentifier()),
        namedtype.OptionalNamedType('parameters', univ.Null())
        # XXX syntax screwed?
#        namedtype.OptionalNamedType('parameters', univ.ObjectIdentifier())
        )

class Extension(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('extnID', univ.ObjectIdentifier()),
        namedtype.DefaultedNamedType('critical', univ.Boolean('False')),
        namedtype.NamedType('extnValue', univ.OctetString())
        )

class Extensions(univ.SequenceOf):
    componentType = Extension()
    sizeSpec = univ.SequenceOf.sizeSpec + constraint.ValueSizeConstraint(1, MAX)

class SubjectPublicKeyInfo(univ.Sequence):
     componentType = namedtype.NamedTypes(
         namedtype.NamedType('algorithm', AlgorithmIdentifier()),
         namedtype.NamedType('subjectPublicKey', univ.BitString())
         )

class UniqueIdentifier(univ.BitString): pass

class Time(univ.Choice):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('utcTime', useful.UTCTime()),
        namedtype.NamedType('generalTime', useful.GeneralizedTime())
        )
    
class Validity(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('notBefore', Time()),
        namedtype.NamedType('notAfter', Time())
        )

class CertificateSerialNumber(univ.Integer): pass

class Version(univ.Integer):
    namedValues = namedval.NamedValues(
        ('v1', 0), ('v2', 1), ('v3', 2)
        )

class TBSCertificate(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.DefaultedNamedType('version', Version('v1', tagSet=Version.tagSet.tagExplicitly(tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0)))),
        namedtype.NamedType('serialNumber', CertificateSerialNumber()),
        namedtype.NamedType('signature', AlgorithmIdentifier()),
        namedtype.NamedType('issuer', Name()),
        namedtype.NamedType('validity', Validity()),
        namedtype.NamedType('subject', Name()),
        namedtype.NamedType('subjectPublicKeyInfo', SubjectPublicKeyInfo()),
        namedtype.OptionalNamedType('issuerUniqueID', UniqueIdentifier().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 1))),
        namedtype.OptionalNamedType('subjectUniqueID', UniqueIdentifier().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 2))),
        namedtype.OptionalNamedType('extensions', Extensions().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3)))
        )

class Certificate(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('tbsCertificate', TBSCertificate()),
        namedtype.NamedType('signatureAlgorithm', AlgorithmIdentifier()),
        namedtype.NamedType('signatureValue', univ.BitString())
        )

class BasicConstraints(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('ca', univ.Boolean(False)),
        namedtype.OptionalNamedType('pathLenConstraint', univ.Integer())
        )

class HashAlgAndValue(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('hashAlg', AlgorithmIdentifier()),
        namedtype.NamedType('hashValue', univ.OctetString())
        )

class IA5StringSequence(univ.SequenceOf):
    componentType = char.IA5String()

class LogotypeDetails(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('mediaType', char.IA5String()),
        namedtype.NamedType('logotypeHash', HashAlgAndValue()),
        namedtype.NamedType('logotypeURI', IA5StringSequence())
        )

class LogotypeImageType(univ.Integer):
    namedValues = namedval.NamedValues(
        ('grayScale', 0), ('color', 1)
        )

class LogotypeImageResolution(univ.Choice):
    componentType = namedtype.NamedTypes(
        namedtype.DefaultedNamedType('numBits', univ.Integer()),
        namedtype.DefaultedNamedType('tableSize', univ.Integer())
        )
    
class LogotypeImageInfo(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.DefaultedNamedType('type', LogotypeImageType('color')),
        namedtype.NamedType('fileSize', univ.Integer()),
        namedtype.NamedType('xSize', univ.Integer()),
        namedtype.NamedType('ySize', univ.Integer()),
        namedtype.OptionalNamedType('resolution', LogotypeImageResolution()),
        namedtype.OptionalNamedType('language', char.IA5String())
        )    

class LogotypeImage(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('imageDetails', LogotypeDetails().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))),
        namedtype.OptionalNamedType('imageInfo', LogotypeImageInfo().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 1))),
        )

class LogotypeImageSequence(univ.SequenceOf):
    componentType = LogotypeImage()

class LogotypeAudioInfo(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('fileSize', univ.Integer()),
        namedtype.NamedType('playTime', univ.Integer()),
        namedtype.NamedType('channels', univ.Integer()),
        namedtype.OptionalNamedType('sampleRate', univ.Integer()),
        namedtype.OptionalNamedType('language', char.IA5String())
        )

class LogotypeAudio(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('audioDetails', LogotypeDetails().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))),
        namedtype.OptionalNamedType('audioInfo', LogotypeAudioInfo().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 1)))
        )

class LogotypeAudioSequence(univ.SequenceOf):
    componentType = LogotypeAudio()

class LogotypeData(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('image', LogotypeImageSequence()),
        namedtype.OptionalNamedType('audio', LogotypeAudioSequence())
        )

class LogotypeReference(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('refStructHash', HashAlgAndValue()),
        namedtype.NamedType('refStructURI', char.IA5String())
        )

class LogotypeInfo(univ.Choice):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('direct', LogotypeData().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))),
        namedtype.NamedType('indirect', LogotypeReference().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 1)))
        )

class LogotypeInfoSequence(univ.SequenceOf):
    componentType = LogotypeInfo()

class OtherLogotypeInfo(univ.Sequence):
    componentType = namedtype.NamedTypes(
        namedtype.NamedType('logotypeType', univ.ObjectIdentifier()),
        namedtype.NamedType('info', LogotypeInfo())
        )
        
class LogotypeExtn(univ.Sequence):
    componentType = namedtype.NamedTypes(
#        namedtype.OptionalNamedType('communityLogos', LogotypeInfoSequence().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))),
        namedtype.OptionalNamedType('issuerLogo', LogotypeInfo().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 1))),
#        namedtype.OptionalNamedType('subjectLogo', LogotypeInfo().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 2))),
#        namedtype.OptionalNamedType('otherLogos', OtherLogotypeInfo().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3))),
        )

# end of ASN.1 data structures

stSpam, stHam, stDump = 0, 1, 2

def readPemFromFile(fileObj):
    state = stSpam
    while 1:
        certLine = fileObj.readline()
        if not certLine:
            break
        certLine = string.strip(certLine)
        if state == stSpam:
            if certLine == '-----BEGIN CERTIFICATE-----':
                certLines = []
                state = stHam
                continue
        if state == stHam:
            if certLine == '-----END CERTIFICATE-----':
                state = stDump
            else:
                certLines.append(certLine)
        if state == stDump:
            substrate = ''
            for certLine in certLines:
                substrate = substrate + base64.b64decode(certLine)
            return substrate

AttrTypes = {
    (2, 5, 4, 3):  "CN",
    (2, 5, 4, 4):  "SN",
    (2, 5, 4, 5):  "S",
    (2, 5, 4, 6):  "C",
    (2, 5, 4, 7):  "L",
    (2, 5, 4, 8):  "ST",
    (2, 5, 4, 10): "O",
    (2, 5, 4, 11): "OU",
    (2, 5, 4, 12): "T",
    (2, 5, 4, 41): "N",
    (2, 5, 4, 42): "GN",
    (2, 5, 4, 43): "I",
    (2, 5, 4, 44): "Q",
    (2, 5, 4, 46): "DN",
    (2, 5, 4, 65): "PS",
    (1, 2, 840, 113549, 1, 9, 1): "emailAddress",
}

def ParseName(n):
    # for each RelativeDistinguishedName
    nm = []
    for tv in n[0]:
        (t,v) = tv[0]
        t = AttrTypes.get(t, t)
        nm.append("%s=%s" % (t, v[1]))
    return ", ".join(nm)

def Asn1Date(u):
    return datetime.strptime(str(u), "%y%m%d%H%M%SZ")

def _PadByte(bits):
  """Pad a string of bits with zeros to make its length a multiple of 8."""
  r = len(bits) % 8
  return ((8-r) % 8)*'0' + bits

def BinToBytes(bits):
  """Convert bit string to byte string."""
  bits = _PadByte(bits)
  octets = [bits[8*i:8*(i+1)] for i in range(len(bits)/8)]
  bytes = [chr(int(x, 2)) for x in octets]
  return "".join(bytes)

def DecodeBin(k):
    return decoder.decode(univ.OctetString(BinToBytes(k.prettyPrint()[1:-2])))[0]

def OIDtoURN(oid):
    return "urn:" + ".".join(map(str, oid))

def ASN1toJSON(a):
    c = a.__class__
    if issubclass(c, univ.Sequence) or issubclass(c, univ.SequenceOf) or issubclass(c, univ.SetOf):
        return [ASN1toJSON(a.getComponentByPosition(i)) for i in range(len(a))]
    if issubclass(c, useful.UTCTime):
        return Asn1Date(a)
    if issubclass(c, univ.Boolean):
        return bool(a)
    if issubclass(c, univ.ObjectIdentifier):
        return OIDtoURN(a)
    if issubclass(c, univ.Integer):
        return long(a)
    if issubclass(c, univ.Null) or (a is None):
        return None
    if issubclass(c, univ.OctetString):
        try:
            return unicode(a)
        except:
            return crypto.b64(str(a))
    if issubclass(c, univ.Choice):
        return ASN1toJSON(a.getComponent())
    if issubclass(c, univ.BitString):
        return BinToBytes(a.prettyPrint()[1:-2])

    return str(c)

def decodeExtension(eid, ev):
    if eid == (1, 3, 6, 1, 5, 5, 7, 1, 12):
        print repr(ev)
        return ASN1toJSON(decoder.decode(ev, asn1Spec=LogotypeExtn())[0])
    ev = ASN1toJSON(decoder.decode(ev)[0])
    return ev

def convertToJSON(cert):
    tbs = cert.getComponentByName("tbsCertificate")
    (ver, serialNumber, signature, issuer, validity, subject, subjectPublicKeyInfo) = tbs[:7]
    subject = ParseName(subject)
    notBefore = Asn1Date(validity[0][0])
    notAfter = Asn1Date(validity[1][0])
    serialNumber = long(serialNumber)
    (pkAlg, pk) = subjectPublicKeyInfo
    pkAlg = pkAlg[0]
    if pkAlg != rsaEncryption:
        raise crypto.CryptoException("Unknown public key algorithm: " + str(pkAlg))

    (n, e) = map(long, DecodeBin(pk))
    rsa = RSA.construct((n,e))
    pub = crypto.PublicKey(key=rsa)

    print tbs.getComponentByName("issuerUniqueID")
    print tbs.getComponentByName("subjectUniqueID")
    extensions = tbs.getComponentByName("extensions")
    c = crypto.Certificate(name=subject, pubkey=pub, serial=serialNumber, notBefore=notBefore, notAfter=notAfter)

    if extensions:
        for e in extensions:
            eid = e.getComponentByName("extnID")                
            crit = e.getComponentByName("critical")
            ev = e.getComponentByName("extnValue")
            ev = decodeExtension(eid, ev)
            if crit:
                c.addCriticalExtension(OIDtoURN(eid), ev)
            else:
                c.addExtension(OIDtoURN(eid), ev)

            #if eid == basicConstraints:

#        print "%s = %s (critical=%s)" % (eid, ev, bool(e.getComponentByName("critical")))
    return c

# Read ASN.1/PEM X.509 certificates on stdin, parse each into plain text,
# then build substrate from it
if __name__ == '__main__':
    import sys
    
    certType = Certificate()

    certCnt = 0

    while 1:
        substrate = readPemFromFile(sys.stdin)
        if not substrate:
            break
        
        cert = decoder.decode(substrate, asn1Spec=certType)[0]
        cert = convertToJSON(cert)
        print cert

        certCnt += 1

        print '*** %s PEM cert(s) de/serialized' % certCnt
