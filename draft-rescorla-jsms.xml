<?xml version="1.0" encoding="US-ASCII"?>
<!-- $Id -->
<?rfc inline="yes"?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="no" ?>
<!--<?rfc strict="yes" ?>-->
<?rfc compact="yes" ?>
<?rfc sortrefs="no" ?>
<?rfc colonspace='yes' ?>
<rfc category="std" docName="draft-rescorla-jsms-00.txt" 
     ipr="pre5378Trust200902">
  <front>
    <title abbrev="JSMS">JavaScript Message Security Format</title>

    <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
      <organization>Skype</organization>

      <address>
        <postal>
          <street>8000 Marina Blvd</street>

          <city>Brisbane</city>

          <region>CA</region>

          <code>94005</code>

          <country>USA</country>
        </postal>

        <email>ekr@skype.net</email>
      </address>
    </author>

    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>1899 Wyknoop Street, Suite 600</street>
          <city>Denver</city>
          <region>CO</region>
          <code>80202</code>
          <country>USA</country>
        </postal>
        <email>jhildebr@cisco.com</email>
      </address>
    </author>



    <date day="02" month="August" year="2010" />

    <abstract>
      <t>
	Many applications require the ability to send cryptographically
	secured messages. While the IETF has defined a number of formats
	for such messages [TODO: REF CMS, PEM, OpenPGP], those formats 
	use encodings which are not congenial for Web applications. 
	This document describes a new cryptographic message format
	which is based on JavaScript Object Notation (JSON) and thus
	is easy for Web applications to generate and parse.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
	Many applications require the ability to send cryptographically
	secured (encrypted, digitally signed, etc.) messages. 
	While the IETF has defined a number of formats for such messages
	[TODO: REF CMS, PEM, OpenPGP], those formats are widely
	viewed as being excessively complicated for the demands of
	Web applications, which typically only need the ability
	to secure simple messages. In addition, existing formats
	use encoding mechanisms (e.g., ASN.1) which are not congenial
	for Web applications. This presents an obstacle to the deployment
	of strong security by such applications.
      </t>
      <t>
	This document describes a new cryptographic message format,
	JavaScript Message Security (JSMS) intended to meet the need of the
	Web environment. While JSMS is modelled on existing
	formats--principally CMS [TODO: REF]--it uses JavaScript Object
	Notation (JSON) rather than ASN.1/BER/DER, making it far easier for
	Web applications to handle. In the interest of simplicity, JSMS also
	omits a number of lesser-used CMS modes (multiple signatures,
	password-based encryption).
      </t>
    </section>
    <section title="Conventions Used In This Document">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <!--<xref
      target="RFC2119"> </xref> TODO -->.</t>
    </section>
    <section title="Overview">
      <t>
	The JSMS message format is simply a JSON dictionary with an appropriate
	collection of fields. For instance, 
	[TODO: Need something here.]
      </t>
      <section title="Operational Modes">
	<t>
	  JSMS supports two operational modes:
	</t><t>
	  <list style="hanging">
	    <t hangText="Encrypted Data"></t><t>
	    A block of data encrypted under a random message encryption
	    key (MEK). The MEK is then separately encrypted for each
	    recipient, either via symmetric or asymmetric encryption.
	    The data is always integrity protected, either via a
	    separate MAC or an AEAD algorithm such as AES-GCM.</t>
	    
	    <t></t>

	    <t hangText="Signed Data"></t><t>
	    A block of data signed by a single signer using his
	    asymmetric key and optionally carrying his certificate.
	    Multiple signatures are not permitted (in our view,
	    this feature has proved to be more trouble than it is
	    generally worth.)
	  </t>
	  </list>
	</t>
	<t>
	  Any other desired security functions are provided by composition
	  of these modes. For instance, a signed and encrypted
	  message is produced by first creating a Signed message and
	  then encrypting that data. (See <xref target="sec.msg-composition"/> for more on composition.
	</t>
      </section>
      <section title="Conventions">
	<t>
	  In general, JSMS follows the following structural conventions:
	</t>
	<t>
	  <list style="hanging">
	    <t hangText="Base64 as the only encoding"> </t>
	    <t>
	    Any data that does not have a straightforward string
	    representation (binary values, large integers, etc.)
	    is base64-encoded. In some cases, hexadecimal encodings
	    might be more convenient, but consistency seems even
	    more important.
	    </t>

	    <t></t>

	    <t hangText="No canonicalization"></t>
	    <t>
	      In most cryptographic message formats (CMS, PKIX, 
	      XML-DSIG [TODO: REF]), canonical encodings are 
	      used to allow the same value to be computed at both
	      sender and recipient (e.g., for digital signatures).
	      This is inconvenient in
	      JSON, which just views messages as a bundle of
	      key/value pairs. Instead, whenever canonicalization
	      would be required, the relevant data is serialized
	      and base64 encoded, with whatever computation is necessary
	      being performed on the base64-encoded version.
	    </t>
	    
	    <t></t>

	    <t hangText="In-memory processing"></t>
	    <t>
	      We assume that the entire message can fit in main
	      memory and make no effort to design a wire representation
	      which can be handled in small chunks in a single pass.
	      This means, for instance, that there is no need to 
	      have a message digest indicator at the beginning of
	      the message and then the signature at the end, as
	      is done in CMS. Fields are simply serialized in
	      whatever order is most convenient for the JSON
	      implementation. The examples in this document are
	      generally shown in whatever order seems most readable and
	      are not normative.
	    </t>
	  </list>
	</t>
	</section>

	<section title="Certificate Processing">
	  <t>
	    Experience has shown that certificate handling 
	    path construction) is one of the trickier parts of
	    building a cryptographic system. While JSMS supports
	    PKIX certificates, it's certificate processing
	    is far simpler than that of CMS. 
	    When a JSMS agent provides its certificate, it must
	    provide an ordered chain (as in TLS [REF]) terminating
	    in its own certificate, thus removing the need to construct
	    certificate paths. In addition, because many implementations
	    will not want to do any ASN.1/BER processing at all, 
	    we define a Web service which applications can use for
	    chain valiation. (See [TODO]).
	  </t>
	</section>
      </section>

      
      <section title="Message Format">
	<section title="Common Elements" anchor="sec.message-common">
	  <t>
	    A JSMS message is simple a JSON dictionary object
	    containing a set of specific values. The following fields
	    MUST be present in all messages:
	  </t>
          <t><list style="hanging">
              <t/>
	      
	      <t hangText="Version:">The version number. For this specification
	      this value MUST be set to the string "1.0"</t>
	      
	      <t/>

	      <t hangText="MessageType:">The type of the message. MUST be either
	      "Signed" or "Encrypted", to indicate a signed message or an
	      encrypted message respectively.</t>
	    </list>
	  </t>
	  <t>
	    
	    
	</section>



	    


	<section title="Signed Data">
	  <t>



	  </t>
	</section>
	<section title="Encrypted Data">
	

	</section>

	<section title="Composition" anchor="sec.msg-composition">


	</section>
      </section>
      
      <section title="IANA Considerations" anchor="sec.iana-cons">
	<t>
	  [TODO]
	  <list style="symbols">
	    <t>Register MIME types</t>
	    <t>Registries for signature, encryption, MAC</t>
	  </list>
	</t>
	  
      </section>

      <section title="Security Considerations" anchor="sec.sec-cons">

      </section>

    <section title="Acknowledgments">
    <t>
      [TODO]
    </t>
    </section>
  </middle>
  
  <back>
    <references title="Normative References">
    </references>
    <references title="Informative References">
    </references> 
  </back>
</rfc>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:nil
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

