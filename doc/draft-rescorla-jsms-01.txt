


Network Working Group                                          R. Barnes
Internet-Draft                                          BBN Technologies
Intended status:  Standards Track                            E. Rescorla
Expires:  January 2, 2012                                     RTFM, Inc.
                                                           J. Hildebrand
                                                     Cisco Systems, Inc.
                                                            July 1, 2011


                   JavaScript Message Security Format
                       draft-rescorla-jsms-00.txt

Abstract

   Many applications require the ability to send cryptographically
   secured messages.  While the IETF has defined a number of formats for
   such messages (e.g.  CMS) those formats use encodings which are not
   easy to use in modern applications.  This document describes the
   JavaScript Message Security format (JSMS), a new cryptographic
   message format which is based on JavaScript Object Notation (JSON)
   and thus is easy for many applications to generate and parse.

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on January 2, 2012.

Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents



Barnes, et al.           Expires January 2, 2012                [Page 1]

Internet-Draft                    JSMS                         July 2011


   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Conventions Used In This Document  . . . . . . . . . . . . . .  3
   3.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .  3
     3.1.  Operational Modes  . . . . . . . . . . . . . . . . . . . .  4
     3.2.  Design Principles  . . . . . . . . . . . . . . . . . . . .  4
     3.3.  Certificate Processing . . . . . . . . . . . . . . . . . .  5
     3.4.  Certificate Discovery  . . . . . . . . . . . . . . . . . .  5
   4.  Message Format . . . . . . . . . . . . . . . . . . . . . . . .  5
     4.1.  Data types . . . . . . . . . . . . . . . . . . . . . . . .  6
     4.2.  Common Elements  . . . . . . . . . . . . . . . . . . . . .  6
     4.3.  SignedData . . . . . . . . . . . . . . . . . . . . . . . .  6
       4.3.1.  Generating a SignedData Object . . . . . . . . . . . .  7
       4.3.2.  Verifying a SignedData Object  . . . . . . . . . . . .  8
     4.4.  AuthenticatedData  . . . . . . . . . . . . . . . . . . . .  8
       4.4.1.  Generating an AuthenticatedData Object . . . . . . . .  9
       4.4.2.  Verifying a AuthenticatedData Object . . . . . . . . .  9
     4.5.  EncryptedData  . . . . . . . . . . . . . . . . . . . . . . 10
       4.5.1.  Generating an EncryptedData Object . . . . . . . . . . 10
       4.5.2.  Verifying a AuthenticatedData Object . . . . . . . . . 10
     4.6.  Useful Objects . . . . . . . . . . . . . . . . . . . . . . 11
       4.6.1.  AlgorithmIdentifier  . . . . . . . . . . . . . . . . . 11
       4.6.2.  PublicKey  . . . . . . . . . . . . . . . . . . . . . . 13
       4.6.3.  WrappedSymmetricKey  . . . . . . . . . . . . . . . . . 14
   5.  Compact Format . . . . . . . . . . . . . . . . . . . . . . . . 15
   6.  Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
     6.1.  Parameters . . . . . . . . . . . . . . . . . . . . . . . . 16
     6.2.  SignedData . . . . . . . . . . . . . . . . . . . . . . . . 17
     6.3.  AuthenticatedData  . . . . . . . . . . . . . . . . . . . . 18
     6.4.  EncryptedData  . . . . . . . . . . . . . . . . . . . . . . 19
   7.  Mapping to CMS . . . . . . . . . . . . . . . . . . . . . . . . 20
   8.  Version Processing . . . . . . . . . . . . . . . . . . . . . . 21
   9.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 21
   10. Security Considerations  . . . . . . . . . . . . . . . . . . . 21
   11. References . . . . . . . . . . . . . . . . . . . . . . . . . . 21
     11.1. Normative References . . . . . . . . . . . . . . . . . . . 21
     11.2. Informative References . . . . . . . . . . . . . . . . . . 22
   Appendix A.  Acknowledgments . . . . . . . . . . . . . . . . . . . 23
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 23




Barnes, et al.           Expires January 2, 2012                [Page 2]

Internet-Draft                    JSMS                         July 2011


1.  Introduction

   Many applications require the ability to send cryptographically
   secured (encrypted, digitally signed, etc.) messages.  While the IETF
   has defined a number of formats for such messages, those formats are
   widely viewed as being excessively complicated for the demands of Web
   applications, which typically only need the ability to secure simple
   messages.  In addition, existing formats use encoding mechanisms
   (e.g., ASN.1 DER) which are not congenial for many classes of
   applications (e.g., Web applications).  This presents an obstacle to
   the deployment of strong security by such applications.

   This document describes a new cryptographic message format,
   JavaScript Message Security (JSMS).  This format intended to meet the
   need of modern applications, including JavaScript-based Web
   applications.  While JSMS is modeled on existing formats --
   principally CMS [RFC5652] -- it uses JavaScript Object Notation
   (JSON) rather than ASN.1, making it far easier for applications to
   handle.  In the interest of simplicity, JSMS also omits many of less
   commonly used CMS modes (such as multiple signatures and password-
   based encryption).


2.  Conventions Used In This Document

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

   In order to enable JSON to carry binary data, JSMS makes extensive
   use of Base64 encoding [RFC4648].  Whenever this document refers to
   Base64 encoding, we mean the URL-safe variant "base64url" encoding.
   As stated in section 3.1 of [RFC4648], Base64 does not allow
   linefeeds.  Since linefeeds are not valid characters in a JSON
   string, whenever a field is specified to be Base64-encoded in this
   document, it MUST NOT include any line breaks.  Base64-encoded fields
   also MUST NOT include JSON-encoded linefeeds such as "\n".  Any
   linebreaks in the middle of Base64-encoded sections of the examples
   in this document have been inserted in order to make the examples fit
   on the page.


3.  Overview

   The JSMS message format is simply a JSON [RFC4627] object with an
   appropriate collection of fields.  Each operating mode will have a
   separate set of fields, with a common field to distinguish between
   the modes.



Barnes, et al.           Expires January 2, 2012                [Page 3]

Internet-Draft                    JSMS                         July 2011


3.1.  Operational Modes

   JSMS supports three operational modes:
   Signed Data
      A block of data signed by a single signer using his asymmetric key
      and optionally carrying his certificate.  Multiple signatures are
      not permitted in order to keep things simple.
   Authenticated Data
      A block of data with authentication and integrity protection
      provided using a symmetric-key Message Authentication Code (MAC).
      The MAC key may be provided in encrypted form (as with Encryped
      Data) or identified by name.
   Encrypted Data
      A block of data encrypted under a random message encryption key
      (MEK).  The MEK is then separately encrypted for each recipient,
      either via symmetric or asymmetric encryption.  The data is always
      integrity protected, through the use of an Authenticated
      Encryption with Associated Data (AEAD) algorithm such as AES-GCM
      or AES-CCM.

   Any other desired security functions are provided by composition of
   these modes.  For instance, a signed and encrypted message is
   produced by first creating a Signed message and then encrypting that
   data.

3.2.  Design Principles

   In general, JSMS follows the following design principles.

   Minimize implementation complexity
      Wherever possible, protocol choices have been made such that the
      time and effort required to implement the protocol in many
      different programming languages will be minimized.  This means
      that optimizations for bandwidth, CPU, and memory utilization have
      been explicitly avoided.
   Base64 as the only encoding
      Any data that does not have a straightforward string
      representation (binary values, large integers, etc.) is base64-
      encoded (see:  [RFC4648]).  In some cases, hexadecimal encodings
      might be more convenient, but consistency is even more important
      to reduce implementation complexity.
   No canonicalization
      In many cryptographic message formats, canonical encodings are
      used to allow the same value to be computed at both sender and
      recipient (e.g., for digital signatures).  This is inconvenient in
      JSON, which just views messages as a bundle of key/value pairs.
      Instead, whenever canonicalization would be required, the relevant
      data is serialized and base64-encoded for transport, allowing both



Barnes, et al.           Expires January 2, 2012                [Page 4]

Internet-Draft                    JSMS                         July 2011


      sides to run computations over the same original set of octets.
   In-memory processing
      We assume that the entire message can fit in main memory and make
      no effort to design a wire representation which can be handled in
      small chunks in a single pass.  This means, for instance, that
      there is no need to have a message digest indicator at the
      beginning of the message and then the signature at the end, as is
      done in CMS.  Fields are simply serialized in whatever order is
      most convenient for the JSON implementation.  The examples in this
      document are generally shown in whatever order seems most readable
      and are not normative.
   Consistency with CMS
      To simplify the adaptation of existing cryptographic modules and
      the validation of JSMS implementations, changes from the CMS
      cryptographic operations are minimized.  JSMS is semantically
      equivalent to a profile of CMS, as described in Section Section 7.

3.3.  Certificate Processing

   Experience has shown that certificate handling (path construction) is
   one of the trickier parts of building a cryptographic system.  While
   JSMS supports PKIX certificates, its certificate processing is far
   simpler than that of CMS.  (It also supports the use of bare public
   keys in order to avoid the use of X.509 altogether.)  When a JSMS
   agent provides its certificate, it must provide an ordered chain (as
   in TLS [RFC5246]) terminating in its own certificate, thus removing
   the need to construct certificate paths.  The certificates MUST be
   ordered with the end-entity certificate first and each certificate
   that follows signing the certificate immediately preceding it.

3.4.  Certificate Discovery

   JSMS will often be used in an online messaging environments with
   users that have an address of the form user@domain, such as email,
   XMPP, or SIP.  As such, protocols such as WebFinger
   [I-D.hammer-webfinger] or an end-to-end protocol can be used to
   retrieve appropriate certificates.  Downstream uses of JSMS SHOULD
   define a discovery mechanism suitable for the intended use.


4.  Message Format

   A JSMS object is a JSON object that encodes cryptographic informaton
   related to a content byte string.  This document specifies the set of
   keys that must be present in a JSMS object, what the associated
   values are, and how these values are generated and processed in order
   to realize security features.  In processing JSMS objects, unknown
   keys MUST be ignored.



Barnes, et al.           Expires January 2, 2012                [Page 5]

Internet-Draft                    JSMS                         July 2011


   JSMS defines three top-level types of secure object, each of which
   provides a specific cryptographic protection to a byte string.
   SignedData:  Signature using a public-key digital signature algorithm
   AuthenticatedData:  Authentication using a Message Authentication
      Code (MAC)
   EncryptedData:  Encryption and authentication using an Authenticated
      Encryption with Associated Data (AEAD) algorithm

4.1.  Data types

   For each field in a JSON object, we define the type of information
   that must be included in that field.  At base are the object, array,
   string, number types defined by JSON.  We also use two special sub-
   classes of strings:  Fields with type "Token" contain a string drawn
   from a defined list of strings (e.g., an IANA registry for algorithm
   names).  Fields with type "ByteString" contain a Base64-encoded byte
   string (note the considerations related to Base64 encoding in Section
   Section 2 above).

   In addition to the primitive data types, Section Section 4.6 defines
   a collection of useful object types that are used by the top-level
   JSMS objects.  These are simply referred to by name when they appear
   as a field value in another object.

4.2.  Common Elements

   The following elements are common to all JSMS messages:
   "version":  REQUIRED Number.  The version of JSMS used by this
      objec.t.  This field MUST be set to 1.
   "type":  REQUIRED Token.  The type of this JSMS object.  This field
      MUST be set to one of the following values
      "signed":  SignedData object
      "authenticated":  AuthenticatedData object
      "encrypted":  EncryptedData object
   "content":  OPTIONAL ByteString.  The content byte string, Base64-
      encoded.
   If the "content" key is not present in a given JSMS object, then the
   JSMS object is "detached".  In this case, the content must be
   associated with the JSMS object through some out-of-band mechanism
   before the JSMS object can be processed.

4.3.  SignedData

   A SignedData object MUST have a "type" field set to "signed".  In
   addition, a SignedData object contains the following keys:






Barnes, et al.           Expires January 2, 2012                [Page 6]

Internet-Draft                    JSMS                         July 2011


   "digestAlgorithm":  REQUIRED AlgorithmIdentifier.  The digest
      algorithm used in signing the content. [[ IANA note ]]
   "signatureAlgorithm":  REQUIRED AlgorithmIdentifier.  The signature
      algorithm used in signing the content [[ IANA note ]]
   "signature":  REQUIRED ByteString.  The Base64-encoded signature
      value
   "key":  REQUIRED PublicKey.  The public key identifier for the
      signer, represented as a PublicKey object (see below)
   "certificates":  OPTIONAL Array of String.  A certificate chain
      associating the signer's public key with an identifier.  Each
      element in the array is a string containing the Base64-encoded
      representation of a DER-formatted certificate.  The certificates
      MUST be ordered with the end-entity certificate first and each
      certificate that follows signing the certificate immediately
      preceding it.
   "certificatesURI":  OPTIONAL String.  An HTTP or HTTPS URI referring
      to a certificate chain.  The referenced resource MUST have type
      "application/json" and contain an array of certificates in the
      same format as the "certificates" element above, including the
      ordering constraint.
   If the "key" value represents the public key as an identifier, then a
   certificate for the signer MUST be provided by setting either the
   "certificates" or "certificatesURL" fields.  Obviously, the subject
   key in the certificate MUST match the identifier in the "key" value;
   the certificate SHOULD contain the subjectKeyIdentifier field, with a
   value matching the "key" value.

   To generate a SignedData object, the originator first computes the
   signature value over the content:
   1.  Compute a message digest by applying the message digest algorithm
       to the content byte string
   2.  Compute the signature value by using the signature algorithm to
       sign the message digest with the private key of an asymmetric key
       pair
   The originator then encodes the SignedData object by including the
   appropriate AlgorithmIdentifiers for the digest and signature
   algorithms, the PublicKey structure for hte public key, and the
   Base64 representations of the signature value and (optionally) the
   content.

4.3.1.  Generating a SignedData Object

   The inputs to the process of generating a SignedData object are:
   o  The content, as a byte string
   o  A digest algorithm
   o  A signature algorithm





Barnes, et al.           Expires January 2, 2012                [Page 7]

Internet-Draft                    JSMS                         July 2011


   o  An asymmetric key pair

   To generate the signature for SignedData object, the originator takes
   the following steps:
   1.  Compute the message digest by applying the digest algorithm to
       the content.
   2.  Compute the signature by using the signature algorithm to sign
       the message digest with the private key from the asymmetric key
       pair.

   The originator then encodes the SignedData object by including the
   appropriate AlgorithmIdentifiers for the digest and signature
   algorithms, the PublicKey structure for hte public key, and the
   Base64 representations of the signature value and (optionally) the
   content.

4.3.2.  Verifying a SignedData Object

   To verify a SignedData object, the recipient takes the following
   steps:
   1.  Verify that the digest and signature algorithms are supported.
       Otherwise, report an error and fail.
   2.  Compute the content byte string by decoding the "content" value
       of the JSMS object.  If the JSMS object does not contain a
       "content" field, retrieve the content by other means.
   3.  Compute the message digest by applying the digest algorithm to
       the content.
   4.  Compute the signature by decoding the "signature" value of the
       JSMS object.
   5.  Compute the public key:
       *  If the key is represented directly, then decode it according
          to the rules specified by the algorithm name.
       *  If the key is represented by an ID, then retrieve the
          corresponding subject public key from the end-entity
          certificate .  If no "certificates" or "certificatesURI" value
          is present, then report an error and fail.
       *  If the key is represented by a URI, retrieve the public key
          from the URI.
   6.  Verify the signature by using the signature algorithm to verify
       the message digest with the public key.

4.4.  AuthenticatedData

   An AuthenticatedData object MUST have a "type" field set to
   "authenticated".  In addition, an AuthenticatedData object contains
   the following keys:





Barnes, et al.           Expires January 2, 2012                [Page 8]

Internet-Draft                    JSMS                         July 2011


   "algorithm":  REQUIRED AlgorithmIdentifier.  The MAC algorithm used
      to authenticate the content.
   "mac":  REQUIRED ByteString.  The MAC value
   "keys":  OPTIONAL Array of WrappedKey.  Wrapped versions of the
      symmetric key used for this MAC.  Each element in the array MUST
      be a WrappedSymmetricKey object (see below).
   "keyIdentifier":  OPTIONAL ByteString. [[ Opaque identifier for MAC
      key. ]]

   An AuthenticatedData object MUST contain either the "key" field or
   the "keyIdentifier" field, so that the recipient knows which key to
   use to verify the MAC.

4.4.1.  Generating an AuthenticatedData Object

   The inputs to the process of generating a AuthenticatedData object
   are:
   o  The content, as a byte string
   o  A MAC algorithm
   o  A MAC key and key identifier, or
   o  One or more recipient keys and key encipherment algorithms

   If the recipient key is specified rather than the MAC key directly,
   then a random MAC key is generated and encoded in a
   WrappedSymmetricKey objects for each recipient (see Section
   Section 4.6.3).  Once the MAC key has been determined, the originator
   uses the MAC algorithm and MAC key to compute the MAC over the
   content byte string.

   The originator then encodes the SignedData object by including the
   appropriate AlgorithmIdentifier for the MAC algorithm and the Base64
   representations of the MAC value and (optionally) the content.  If
   the MAC key was specified directly, then the Base64 representation of
   the key identifier is set as the "keyIdentifier" value; otherwise,
   the WrappedSymmetricKey objects are collected in an array and set as
   the "keys" value.

4.4.2.  Verifying a AuthenticatedData Object

   To verify a AuthenticatedData object, the recipient takes the
   following steps:
   1.  Verify that the MAC algorithms are supported.  If not, report an
       error and fail.
   2.  Compute the content byte string by decoding the "content" value
       of the JSMS object.  If the JSMS object does not contain a
       "content" field, retrieve the content by other means.





Barnes, et al.           Expires January 2, 2012                [Page 9]

Internet-Draft                    JSMS                         July 2011


   3.  Compute the MAC key:
       *  If the "keyIdentifier" value is present and represents a known
          key, use the identified key.
       *  If the "keys" value is present, check each WrappedPublicKey
          object to determine if it matches a known key for this
          recipient.  If any of the wrapped keys matches, unwrap the key
          from the first one and use it (see Section Section 4.6.3).
          Otherwise, report an error and fail.
   4.  Use the MAC algorithm and MAC key to compute the MAC over the
       content byte string
   5.  Decode the MAC value from the "mac" field.
   6.  Verify that the computed MAC matches the MAC from the object.

4.5.  EncryptedData

   An EncryptedData object MUST have a "type" field set to "encrypted".
   Note also that in an EncryptedData object, the "content" field
   contains the encrypted form of the content, not the content itself
   (as plaintext).  An EncryptedData object contains the following keys
   in addition to any common fields:
   "algorithm":  REQUIRED AlgorithmIdentifier.  The encryption algorithm
      used to encrypt the content
   "keys":  REQUIRED Array of WrappedKey.  Wrapped versions of the
      symmetric key used to encrypt the content.  Each element in the
      array MUST be a WrappedSymmetricKey object (see below).

4.5.1.  Generating an EncryptedData Object

   The inputs to the process of generating a SignedData object are:
   o  The content, as a byte string
   o  A encryption algorithm
   o  One or more recipient keys and key encipherment algorithms

   The originator generates a random encryption key of a length suitable
   for the encryption algorithm, then encodes it in a
   WrappedSymmetricKey object for each recipient (see Section
   Section 4.6.3).  The content is then encrypted using the generated
   encryption key and the specified encryption algorithm.

   The originator then encodes the EncryptedData object by including the
   appropriate AlgorithmIdentifier for the encryption algorithm, an
   array containing the WrappedSymmetricKey objects, and (optionally)
   the Base64 representation of the content.

4.5.2.  Verifying a AuthenticatedData Object

   To decrypt an EncryptedData object, the recipient takes the following
   steps:



Barnes, et al.           Expires January 2, 2012               [Page 10]

Internet-Draft                    JSMS                         July 2011


   1.  Verify that the encryption algorithm is supported.  If not,
       report an error and fail.
   2.  Compute the content byte string by decoding the "content" value
       of the JSMS object.  If the JSMS object does not contain a
       "content" field, retrieve the content by other means.
   3.  Locate the encryption key:  Check each WrappedPublicKey object to
       determine if it matches a known key for this recipient.  If any
       of the wrapped keys matches, unwrap the key from the first one
       and use it (see Section Section 4.6.3).  Otherwise, report an
       error and fail.
   4.  Decrypt the content using the encryption key and the specified
       encryption algorithm.
   5.  Verify that the integrity check in the AEAD decryption was
       successful.  If not, report an error and fail.
   6.  Return the decrypted content.

4.6.  Useful Objects

   In this section we define some common object types that are used
   across the top-level objects above.

4.6.1.  AlgorithmIdentifier

   An AlgorithmIdentifier object names a cryptographic algorithm and
   specifies any associated parameters.  If the algorithm has no
   parameters, then it the AlgorithmIdentifier object is simply a token
   representing the name of the algorithm. [[ Note about registries ]]

   If the algorithm specifies parameters, the AlgorithmIdentifier object
   is a JSON object.  The object must contain a field "name" specifying
   the name of the algorithm.  Any other fields are specified in the
   algorithm definition

   The following table summarizes the algorithms to be used with JSMS.
   [[ More detail to be added later, in a separate document ]]
















Barnes, et al.           Expires January 2, 2012               [Page 11]

Internet-Draft                    JSMS                         July 2011


   Name        Parameters   Reference         Example
   =====================================================================

   SIGNING
   rsa         no           [RFC3447]         "rsa"
   dsa         yes (p,q,g)  [FIPS186]         {name:"dsa",
                                                p:1, q:2, g:3}
   ecdsa       yes (curve)  [RFC6090]         {name:"ecdsa",
                                                curve:"P-256"}

   DIGEST
   sha1        no           [FIPS180-1]       "sha1"
   sha256      no           [FIPS180-3]       "sha256"
   sha384      no           [FIPS180-3]       "sha384"
   sha512      no           [FIPS180-3]       "sha512"

   MAC
   hs1         no           [FIPS180-1]       "hs1"
   hs256       no           [FIPS180-3]       "hs256"
   hs384       no           [FIPS180-3]       "hs384"
   hs512       no           [FIPS180-3]       "hs512"

   ENCRYPTION
   aes-ccm     yes (nonce)  [RFC3610]         {name:"aes-ccm",
                                                nonce:"ZONce...l7IU-g"}
   aes-gcm     yes (iv)     [McGrew & Viega]  {name:"aes-gcm",
                                                iv:"ZONce...l7IU-g"}

   KEY ENCIPHERMENT
   aes         no           [RFC3394]         "aes"
   rsaes-oaep  no           [RFC3447]         "rsaes-oaep"

   KEY AGREEMENT
   ecdh-es     yes (curve)  [RFC6090]         "ecdh-es"

   Obviously, there will be more detail needed beyond the above, and
   some IANA considerations to create the necessary registries.  For
   some algorithms, there will be specific notes about how they are to
   be used with JSMS, for example:
   o  The signature value produced by DSA is comprised of two integers.
      The byte string to be filled in the "signature" field is the two-
      element JSON array containing two integers, "[r,s]"
   o  RSAES-OAEP is always used with SHA-256 and the default MGF1
      masking generation function
   o  Elliptic curves may only be specified by name, not by directly
      specifying curve parameters. [[ We may define our own registry, or
      re-use the ones from TLS/IKE. ]]




Barnes, et al.           Expires January 2, 2012               [Page 12]

Internet-Draft                    JSMS                         July 2011


   o  AEAD algorithms are only used for authenticated encryption; there
      is never associated data.  Further AEAD algorithms may be defined
      using [draft-mcgrew-aead-aes-cbc-hmac-sha1]

4.6.2.  PublicKey

   A PublicKey object describes the public key used by a signer.  The
   key may be specified as a JSON structure directly, as a URI, or as an
   identifier.  A PublicKey object has the following fields:
   "type"  OPTIONAL String.  The name of the algorithm with which this
      key is to be used
   "id"  OPTIONAL ByteString.  An identifier for the key
   "uri"  OPTIONAL String.  A URI pointing to a direct form of the key

   If the key is specified directly, then the "type" key MUST be
   present; the "id" and "uri" fields MAY be present.  Subsequent
   entries in the array specify the elements of the key, in a manner
   determined by the algorithm.  Formats for RSA and ECDH/ECDSA public
   keys are specified below.

   If the key is referenced by an opaque identifier or "fingerprint",
   then the "id" field MUST be present, and contain the Base64-encoded
   SHA-1 hash of the public key, represented as a DER-encoded
   subjectPublicKeyInfo data structure.  (This fingerprint format is the
   same as the one included in the subjectKeyIdentifier field in an
   X.509 certificate.)

   If the key is provided as a URI, then the "uri" field MUST be
   present, containing a URI where the key can be retrieved, either in
   the JSON format described above.  The method that the recipient of a
   JSMS object uses to retrieve the key will depend on the URI scheme.
   For HTTP URIs, the relying party MUST issue an HTTP request with the
   GET method and an Accept header including the MIME type for JSMS
   PublicKey object, "[[MIMETYPE]]".  For MAILTO, SIP, and XMPP URIs,
   the recipient MAY use the WebFinger protocol [[REF]] to retrieve a
   public key for the user.

   Example:  {"id":  "i1LbR8FCEw-aiFcAAfUvpp75wdY="}

   Example:  {"uri":  "xmpp:juliet@example.com"}

4.6.2.1.  RSA Public Key

   An RSA public key comprises two additional parameters in addition to
   the algorithm identifier "rsa".






Barnes, et al.           Expires January 2, 2012               [Page 13]

Internet-Draft                    JSMS                         July 2011


   "n":  REQUIRED Integer.  The modulus
   "e":  REQUIRED Integer.  The public exponent

   Example:  {"name":"rsa", "n":98739...04251, "e":  3}

4.6.2.2.  Elliptic-Curve Public Key

   Public keys for several types of elliptic curve algorithms, including
   ECDSA and ECDH, have the same format, namely an point on a specified
   elliptic curve.  In an elliptic curve PublicKey object, the curve
   parameters are specified in the algorithm identifier, and there are
   two additional fields that specify the point on the curve:
   "x":  REQUIRED ByteString.  The x coordinate of the point
   "y":  REQUIRED Integer.  The y coordinate of the point.  MUST be
      equal to 0 or 1.

   These coordinates correspond to the compressed form of an elliptic
   curve point, as specified in [[REF:SEC01/RFC5840]].  In terms of the
   calculation specified in section 2.3.3 of [[SEC01]], the "x"
   coordinate is the byte string X and the "y" coordinate is the reduced
   y coordinate (or, equivalently, Y mod 2).

   Example:  {"name":"ecdh",
   "x":"IIIs_x1m6Na6xKN37vOwvy7AvFeG9HhBN2EN3u5EZQ4", "y":  1}

4.6.3.  WrappedSymmetricKey

   In JSMS objects that use symmetric keys (for MAC or encryption), it
   is necessary for the originator to convey the symmetric key used for
   in JSMS computations to the recipient.  The WrappedSymmetricKey
   object is a JSON object that allows these keys to be provided either
   using key transport or key agreement.  The following fields may be
   present in a WrappedSymmetricKey object:
   "type":  REQUIRED TOKEN The type of wrapping being done.  This
      document defines the following values for this field:
      "keyEncryption":  Symmetric key transport.  The "KEKIdentifier"
         field MUST be present.  Any other non-required fields MUST be
         ignored.
      "keyTransport":  Asymmetric key transport.  The "ecipientKey"
         field MUST be present.  Any other non-required fields MUST be
         ignored.
      "keyAgreement":  Key agreement.  The "originatorKey" and
         "recipientKey" MUST be present, and the "userKeyMaterial" field
         MAY be present.  Any other non-required fields MUST be ignored.







Barnes, et al.           Expires January 2, 2012               [Page 14]

Internet-Draft                    JSMS                         July 2011


   "algorithm":  REQUIRED AlgorithmIdentifier The algorithm used to
      encrypt the symmetric key
   "encryptedKey":  REQUIRED BYTES The symmetric key, encrypted
      according to the algorithm indicated by the "a" value
   "KEKIdentifier":  OPTIONAL BYTES An opaque identifier for the
      symmtric key encryption key
   "originatorKey":  OPTIONAL PublicKey The public key of the originator
   "recipientKey":  OPTIONAL PublicKey The public key of the recipient
   "userKeyMaterial":  OPTIONAL BYTES User key material

   [[ How to perform wrapping/unwrapping ]]


5.  Compact Format

   The compact JSON format of a JSMS object is identical to the normal
   JSMS format, except that field names are replaced with shorter
   equivalent field names.  Translations for the field names above are
   given in the table below.  Note that in a given JSMS object, all
   field names MUST be either in the long form or the compact form.  An
   implementation MUST reject a JSMS object with mixed long and short
   names as improperly formatted.

   [[ TODO:  Update this table ]]



























Barnes, et al.           Expires January 2, 2012               [Page 15]

Internet-Draft                    JSMS                         July 2011


   Common                      EncryptedData
   ======                      =============
   Version             v       Algorithm           a
   Type                t       Key                 k
     SignedData        s
     AuthenticatedData a
     EncryptedData     e       WrappedKey
   Content             c       =====================
                               Type                t
                                 KeyEncryptionKey  e
   SignedData                    KeyTransport      t
   ==========                    KeyAgreement      a
   DigestAlgorithm     da      Algorithm           a
   SignatureAlgorithm  sa      EncryptedKey        k
   Signature           s       KEKIdentifier       i
   PublicKey           p       OriginatorKey       o
   Certificates        c       RecipientKey        r
   Certificates (URI)  cu      UserKeyMaterial     u


   AuthenticatedData
   =================
   Algorithm           a
   MAC                 m
   Key                 k
   KeyIdentifier       ki

   In applications where a JSMS object is required to be URL-safe, it is
   RECOMMENDED that it be rendered in the compact serialization, then
   Base64-encoded.


6.  Examples

   This section contains complete examples of all three JSMS types.

6.1.  Parameters














Barnes, et al.           Expires January 2, 2012               [Page 16]

Internet-Draft                    JSMS                         July 2011


   RSA key:
   n = 12237824263694976709651031408224222555291991012810482177
       92035786941828977156926971807863278433272099745881797299
       85336687220073096675483822073402642772681280616976104546
       17255329475427018303562916009664448746047222690146365929
       82951349410567289583328152613883921620510403508194065665
       63967272795487285560945461681
   d = 75878357104421224437595505023603656489355639532714946259
       33346690019564595079379205549922077473184883832629939313
       60018964125252953813614463578240747832202105107893654165
       79392505080998449581120603587386341503989723156683831337
       82007353216712737164755944535635260836679769708872556214
       3293140567116070641632520193
   e = 65537

   Key Tag:       01f47ad049e8b81b05f32825a988cd5212ce781e
   Key Encryption Key:    4A5055F46000455098EFBF40EF23752B
   AuthenticatedData Key: bd5b0a3fefd399c3dca6ac1a4e4823cf
                          c5fb037324ff3a1ffebb8ab98c402869
   EncryptedData Key (E): 8a7d6ec1c0be44173a530ebc41338343
   EncryptedData Key (A): 644a02dd5ef168731cf4e6d86f0da8f2
                          2d8d3a55afd4275a8b6526d02502a399

   Content:
   "Attack at dawn!"

6.2.  SignedData

   In this object the content is signed under the specified RSA key
   pair, using SHA1 as the digest.





















Barnes, et al.           Expires January 2, 2012               [Page 17]

Internet-Draft                    JSMS                         July 2011


   {
       "version": 1,
       "type": "signed",
       "content": "QXR0YWNrIGF0IGRhd24h",
       "digestAlgorithm": "sha1",
       "signatureAlgorithm": "rsa"
       "signature": "FTzVmWfkW5Lajck73of7y9zbYj3k5ok34mKIteVpka
                     lzx9ILAiluMngBJJZPQdm2R_CqdH8Vfqxfuplj0w4X
                     plfO3xcCZfS3L8bnoEmHvXI9a3Wii_2dCnBg6xl845
                     6xOUors2dCQS7kjlbPdeYe2BEOomkfaNFwnHfpV-7W
                     Phg=",
       "key": {
           "e": 65537,
           "type": "rsa",
           "n": 12237824263694976709651031408224222555291991012
                81048217792035786941828977156926971807863278433
                27209974588179729985336687220073096675483822073
                40264277268128061697610454617255329475427018303
                56291600966444874604722269014636592982951349410
                56728958332815261388392162051040350819406566563
                967272795487285560945461681
       },
   }

6.3.  AuthenticatedData

   In this object the content is authenticated with a MAC under a
   randomly-generated key (AuthenticatedData Key above), wrapped using
   the key encryption key above, identified by the above key tag.
   {
       "version": 1,
       "type": "authenticated"
       "content": "QXR0YWNrIGF0IGRhd24h",
       "algorithm": "hmac-sha1",
       "mac": "Xy2Q7eLaBvhgco5HV26HePCnRf4=",
       "keys": [{
           "type": "keyEncryption",
           "algorithm": "aes",
           "encryptedKey": "eDGbPl0KSz3V5mVnUHWbIHAuZknDGLEJqVz
                            Lh8RBJL4ELtbpJfVT_Q==",
           "KEKIdentifier": "AfR60EnouBsF8yglqYjNUhLOeB4="
       }],
   }

   As another example, the following object uses the defined key as the
   MAC key directly (instead of as a key encryption key), and uses the
   compact format.  The object is shown both in raw JSON form and in the
   Base64 encoding.



Barnes, et al.           Expires January 2, 2012               [Page 18]

Internet-Draft                    JSMS                         July 2011


   {"v":1,"t":"a","a":"hs1","mac":"Xy2Q7eLaBvhgco5HV26HePCnRf4=",
     "i":"AfR60EnouBsF8yglqYjNUhLOeB4="}

   eyJ2IjoxLCJ0IjoiYSIsImEiOiJoczEiLCJtYWMiOiJYeTJRN2VMYUJ2aGdjbzVI
   VjI2SGVQQ25SZjQ9IiwiaSI6IkFmUjYwRW5vdUJzRjh5Z2xxWWpOVWhMT2VCND0i
   fQo


6.4.  EncryptedData

   In this object, the content is encrypted under the general AEAD
   algorithm using AES-128-CBC for encryption and HMAC-SHA1 for
   authentication.  The keys are described above as "EncryptedData Key
   (E)" and "EncryptedData Key (A)", respectively.  The temporary keys
   are wrapped using the PKCS#1 wrapping, under the RSA key pair above.




































Barnes, et al.           Expires January 2, 2012               [Page 19]

Internet-Draft                    JSMS                         July 2011


   {
       "version": 1,
       "type": "encrypted",
       "content": "eZBqDaw8FutMxIBCOGLJDNU4gc2sIy7PWI5kZY
                   l2EcA2rCYb",
       "algorithm": {
           "nonce": "bhNkT0cN8jSl22Z0twATqQ==",
           "encryption": "aes128-cbc",
           "integrity": "hs1",
           "name": "aead-gen",
           "iv": "AHSd4oUV4VPvvg98W98SZg=="
       }
       "keys": [{
           "type": "keyTransport",
           "algorithm": "rsaes-oaep"
           "encryptedKey": "f5xLEzFMTMbXADWHmrLZjrFTbfMKNk3mwTF
                            RCjeh51ibwOIStVHGXrFsSstT8rqz_9E7r5
                            4XJD40QY5lQSc0tDq0yGRao9AjgLeHCFWDX
                            40WeV80xyzaImnqV9yl20ruKuvC47EdeQ7f
                            zhs6dnc-VCdHr_iXJtHTciR3YLccgHk=",
           "recipientKey": {
               "e": 65537,
               "type": "rsa",
               "n": 1223782426369497670965103140822422255529199
                    1012810482177920357869418289771569269718078
                    6327843327209974588179729985336687220073096
                    6754838220734026427726812806169761045461725
                    5329475427018303562916009664448746047222690
                    1463659298295134941056728958332815261388392
                    1620510403508194065665639672727954872855609
                    45461681
           },
       }],
   }


7.  Mapping to CMS

   [[ SignedData == SignedData, AuthenticatedData == AuthenticatedData,
   EncryptedData == AuthEnvelopedData ]]

   [[ AlgorithmIdentifier == AlgorithmIdentifier ]]

   [[ PublicKey == SubjectPublicKeyInfo.  In the latter case, equivalent
   to SKId+self-signed ]]

   [[ WrappedSymmetricKey == RecipientInfo ]]




Barnes, et al.           Expires January 2, 2012               [Page 20]

Internet-Draft                    JSMS                         July 2011


8.  Version Processing

   For the moment, all version numbers in the protocol MUST be 1.0.
   Receivers MUST return an error for any other version number.  More
   interesting version processing will be defined in the future.


9.  IANA Considerations

   [TODO]
   o  Register MIME types
   o  Registries for algorithms


10.  Security Considerations

   Much more to follow here.

   [[ Notes on identity for SignedData and AuthenticatedData:  It is
   important to note that the above verification process only checks
   that the JSMS object was signed with a given public key.  In order
   for this information to be useful to an applications, it is usually
   necessary to bind the public key to an application-layer identifier.
   If the "certificates" or "certificatesURI" value is present, then the
   recipient SHOULD verify that the chain is valid, and that the the
   end-entity certificate chains to a trust anchor.  In this case, the
   recipient can consider the identity asserted in the end-entity
   certificate to be bound to the public key.  Applications using this
   specification without certificates will need to specify an
   alternative mechanism for binding public keys to identifiers. ]]


11.  References

11.1.  Normative References

   [RFC2045]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", RFC 2045, November 1996.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC3339]  Klyne, G., Ed. and C. Newman, "Date and Time on the
              Internet: Timestamps", RFC 3339, July 2002.

   [RFC3447]  Jonsson, J. and B. Kaliski, "Public-Key Cryptography
              Standards (PKCS) #1: RSA Cryptography Specifications



Barnes, et al.           Expires January 2, 2012               [Page 21]

Internet-Draft                    JSMS                         July 2011


              Version 2.1", RFC 3447, February 2003.

   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, "Randomness
              Requirements for Security", BCP 106, RFC 4086, June 2005.

   [RFC4627]  Crockford, D., "The application/json Media Type for
              JavaScript Object Notation (JSON)", RFC 4627, July 2006.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, October 2006.

   [RFC5116]  McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", RFC 5116, January 2008.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008.

   [RFC5649]  Housley, R. and M. Dworkin, "Advanced Encryption Standard
              (AES) Key Wrap with Padding Algorithm", RFC 5649,
              September 2009.

   [I-D.zyp-json-schema]
              Zyp, K. and G. Court, "A JSON Media Type for Describing
              the Structure and Meaning of JSON Documents",
              draft-zyp-json-schema-03 (work in progress),
              November 2010.

   [FIPS-180-3]
              National Institute of Standards and Technology (NIST),
              "Secure Hash Standard (SHS)", FIPS PUB 180-3,
              October 2008.

11.2.  Informative References

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, January 2005.

   [I-D.hammer-webfinger]
              Hammer-Lahav, E., Fitzpatrick, B., and B. Cook, "The
              WebFinger Protocol", draft-hammer-webfinger-00 (work in
              progress), October 2009.




Barnes, et al.           Expires January 2, 2012               [Page 22]

Internet-Draft                    JSMS                         July 2011


   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, September 2009.

   [krawczyk-ate]
              Krawczyk, H., "The Order of Encryption and Authentication
              for Protecting Communications (or: How Secure Is SSL?)",
              Advances in cryptology--CRYPTO 2001 August 2001.

   [GCM]      National Institute of Standards and Technology (NIST),
              "Recommendation for Block Cipher Modes of Operation:
              Galois/Counter Mode (GCM) and GMAC", SP 800-38D,
              November 2007.


Appendix A.  Acknowledgments

   [TODO]


Authors' Addresses

   Richard Barnes
   BBN Technologies
   1300 N. 17th St.
   Arlington, VA  22209
   USA

   Email:  rbarnes@bbn.com


   Eric Rescorla
   RTFM, Inc.
   2064 Edgewood Drive
   Palo Alto, CA  94303
   USA

   Email:  ekr@rtfm.com


   Joe Hildebrand
   Cisco Systems, Inc.
   1899 Wyknoop Street, Suite 600
   Denver, CO  80202
   USA

   Email:  jhildebr@cisco.com





Barnes, et al.           Expires January 2, 2012               [Page 23]

