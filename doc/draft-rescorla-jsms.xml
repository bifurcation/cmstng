<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY rfc5116 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5116.xml">
<!ENTITY rfc2045 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY rfc3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY rfc4086 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml">
<!ENTITY rfc5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY rfc3447 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY rfc5649 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5649.xml">
]>
<!-- $Id -->
<?rfc inline="yes"?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="no" ?>
<?rfc colonspace='yes' ?>
<rfc category="std" docName="draft-rescorla-jsms-00.txt"
     ipr="pre5378Trust200902">
  <front>
    <title abbrev="JSMS">JavaScript Message Security Format</title>

    <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
      <organization>Skype</organization>

      <address>
        <postal>
          <street>8000 Marina Blvd</street>

          <city>Brisbane</city>

          <region>CA</region>

          <code>94005</code>

          <country>USA</country>
        </postal>

        <email>ekr@skype.net</email>
      </address>
    </author>

    <author fullname="Joe Hildebrand" initials="J." surname="Hildebrand">
      <organization>Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>1899 Wyknoop Street, Suite 600</street>

          <city>Denver</city>

          <region>CO</region>

          <code>80202</code>

          <country>USA</country>
        </postal>

        <email>jhildebr@cisco.com</email>
      </address>
    </author>

    <date day="26" month="December" year="2010" />

    <abstract>
      <t>Many applications require the ability to send cryptographically
      secured messages. While the IETF has defined a number of formats for
      such messages [TODO: REF CMS, PEM, OpenPGP], those formats use encodings
      which are not congenial for Web applications. This document describes a
      new cryptographic message format which is based on JavaScript Object
      Notation (JSON) and thus is easy for Web applications to generate and
      parse.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Many applications require the ability to send cryptographically
      secured (encrypted, digitally signed, etc.) messages. While the IETF has
      defined a number of formats for such messages [TODO: REF CMS, PEM,
      OpenPGP], those formats are widely viewed as being excessively
      complicated for the demands of Web applications, which typically only
      need the ability to secure simple messages. In addition, existing
      formats use encoding mechanisms (e.g., ASN.1) which are not congenial
      for Web applications. This presents an obstacle to the deployment of
      strong security by such applications.</t>

      <t>This document describes a new cryptographic message format,
      JavaScript Message Security (JSMS) intended to meet the need of the Web
      environment. While JSMS is modelled on existing formats - principally
      CMS [TODO: REF]--it uses JavaScript Object Notation (JSON) rather than
      ASN.1/BER/DER, making it far easier for Web applications to handle. In
      the interest of simplicity, JSMS also omits as many as possible of the
      CMS modes (multiple signatures, password-based encryption).</t>
    </section>

    <section title="Conventions Used In This Document">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref target="RFC2119">
      </xref>.</t>
    </section>

    <section title="Overview">
      <t>The JSMS message format is simply a JSON dictionary with an
      appropriate collection of fields. For instance, [TODO: Need something
      here.]</t>

      <section title="Operational Modes">
        <t>JSMS supports two operational modes:</t>

        <t><list style="hanging">
            <t hangText="Encrypted Data"></t>

            <t>A block of data encrypted under a random message encryption key
            (MEK). The MEK is then separately encrypted for each recipient,
            either via symmetric or asymmetric encryption. The data is always
            integrity protected, either via a separate MAC or an AEAD
            algorithm such as AES-GCM.</t>

            <t>CJ - can we just use AES-CCM here ?</t>

            <t hangText="Signed Data"></t>

            <t>A block of data signed by a single signer using his asymmetric
            key and optionally carrying his certificate. Multiple signatures
            are not permitted to keep things simple.</t>
          </list></t>

        <t>Any other desired security functions are provided by composition of
        these modes. For instance, a signed and encrypted message is produced
        by first creating a Signed message and then encrypting that data. (See
        <xref target="sec.msg-composition"></xref> for more on
        composition.</t>
      </section>

      <section title="Conventions">
        <t>In general, JSMS follows the following structural conventions:</t>

        <t><list style="hanging">
            <t hangText="Base64 as the only encoding"></t>

            <t>Any data that does not have a straightforward string
            representation (binary values, large integers, etc.) is
            base64-encoded. In some cases, hexadecimal encodings might be more
            convenient, but consistency seems even more important.</t>

            <t></t>

            <t hangText="No canonicalization"></t>

            <t>In most cryptographic message formats (CMS, PKIX, XML-DSIG
            [TODO: REF]), canonical encodings are used to allow the same value
            to be computed at both sender and recipient (e.g., for digital
            signatures). This is inconvenient in JSON, which just views
            messages as a bundle of key/value pairs. Instead, whenever
            canonicalization would be required, the relevant data is
            serialized and base64 encoded for transport or a well defined
            order of the relevant fields is defines so both sides can compute
            the relevant data.</t>

            <t></t>

            <t hangText="In-memory processing"></t>

            <t>We assume that the entire message can fit in main memory and
            make no effort to design a wire representation which can be
            handled in small chunks in a single pass. This means, for
            instance, that there is no need to have a message digest indicator
            at the beginning of the message and then the signature at the end,
            as is done in CMS. Fields are simply serialized in whatever order
            is most convenient for the JSON implementation. The examples in
            this document are generally shown in whatever order seems most
            readable and are not normative.</t>
          </list></t>
      </section>

      <section title="Certificate Processing">
        <t>Experience has shown that certificate handling path construction)
        is one of the trickier parts of building a cryptographic system. While
        JSMS supports PKIX certificates, its certificate processing is far
        simpler than that of CMS. When a JSMS agent provides its certificate,
        it must provide an ordered chain (as in TLS [REF]) terminating in its
        own certificate, thus removing the need to construct certificate
        paths. In addition, because many implementations will not want to do
        any ASN.1/BER processing at all, we define a Web service which
        applications can use for chain validation. (See [TODO]).</t>
      </section>

      <section title="Certificate Discovery">
        <t>As this will generally be used in an online messaging environment
        with suers that have an address of the form user@domain, such as
        email, XMPP, or SIP, this specification defines a way to use HTTPS
        using a well known URL [TODO REF[ to find other users certificates and
        public keys. (See [TODO]).</t>
      </section>
    </section>

    <section title="Message Format">
      <section anchor="sec.content" title="Content Object">
        <t>JSMS operates by providing transformations on "Content" objects,
        which are just mime-typed JSON objects. These objects are then wrapped
        in a signed/encrypted wrapper:</t>

        <t>[[OPEN ISSUE: Do we want to have both the schema description and
        the bullet point description... CJ: Lets move all scheme to relax NG
        and move it to an appendix and put simple XML examples here. Like w3c
        docs. ]</t>

        <figure>
          <!--begin-pdu-->

          <artwork><![CDATA[
var content_schema={
  "description":"Message contents",
  "type":"object":
  "properties":{
      "ContentType":{
        "description":"A MIME content type",
        "type":"string",
        },
        "Data":{
        "description":"The underlying data",
        "type":"string",
        }
}};
               ]]></artwork>
        </figure>

        <t>The meaning of the fields is as follows:</t>

        <t><list style="hanging">
            <t></t>

            <t hangText="ContentType:">A MIME <xref target="RFC2045"></xref>
            media type indicating the type of the "Data" field.</t>

            <t hangText="Data:">The data value. [OPEN ISSUE: Do we need an
            encoding here? CJ - Yes Base64]</t>
          </list></t>

        <t>Signing and encryption transform a "Content" object into "Signed"
        and "Encrypted" objects respectively. Verification and decryption
        transform "Signed" and "Encrypted" objects back into "Content"
        objects.</t>
      </section>

      <section anchor="sec.message-common" title="Common Elements">
        <t>A JSMS message is simple a JSON dictionary object containing a set
        of specific values.</t>

        <figure>
          <!--begin-pdu-->

          <artwork><![CDATA[
var message_schema={
  "description":"The basic schema for a JSMS message",
  "type":"object",
  "properties":{
    "Type":{
       "description":"Message type",
       "type":"string",
       "enum":["signed", "encrypted"]
     },
     "Version":{
       "description":"Version number for the message",
       "type":"string",
       "enum":["1.0"]
       }
   }
};
               ]]></artwork>
        </figure>

        <t>The following fields MUST be present in all messages:</t>

        <t><list style="hanging">
            <t></t>

            <t hangText="Version:">The version number. For this specification
            this value MUST be set to the string "1.0". [TODO: Version
            processing.]</t>

            <t></t>

            <t hangText="Type:">The type of the message. MUST be either
            "signed" or "encrypted", to indicate a signed message (<xref
            target="sec.signed"></xref>) or an encrypted message (<xref
            target="sec.encrypted"></xref>) respectively.</t>
          </list></t>

        <t></t>
      </section>

      <section anchor="sec.signed" title="Signed Data">
        <t>A "signed" message contains a signed data block plus a digital
        signature over that data. Only one signer is allowed.</t>

        <figure>
          <!--begin-pdu-->

          <artwork><![CDATA[
var signed_schema = {
  "description":"A signed message",
  "type":"object",
  "extends":message_schema,
  "properties":{
    "Signature":{
       "description":"The signature over the SignedData",
       "type":"object",
       "properties":{
           "Value":{
               "description":"the content to be signed",
               "type":"string"},
            "DigestAlgorithm":{
               "description":"",
               "type":"string",
               "enum":["SHA1", "SHA256"] },
             "SignatureAlgorithm":{
               "description":"",
               "type":"string",
               "enum":["RSA-PKCS1-1.5"] },
            "Signer":{
               "description":"",
               "type":"string",
               "format":"email" },
            "CertChain": {
               "description":"The signer's cert chain",
               "type":certchain_schema
               }
}}}};
               ]]></artwork>
        </figure>

        <t>[[OPEN ISSUE: How do we represent enums that correspond to
        algorithm identifiers and hence registries. CJ: Make new registries.
        ]]</t>

        <t>The meaning of the fields is described below:</t>

        <t><list style="hanging">
            <t></t>

            <t hangText="Value:">The data over which the signature is
            computed. This value MUST be a base64-encoded version of a
            "Content" structure (see <xref target="sec.content"></xref>).
            [OPEN ISSUE: is this exactly what we want?]</t>

            <t></t>

            <t hangText="DigestAlgorithm:">The message digest used to compute
            the signature. This field MUST be present for RSA-based signatures
            but MAY be omitted for future signatures which do not allow
            flexible digests.</t>

            <t></t>

            <t hangText="SignatureAlgorithm:">The signature algorithm used to
            compute the signature. This field MUST be present.</t>

            <t></t>

            <t hangText="Signer:">The signer's identity, expressed as a URI
            <xref target="RFC3986"></xref> This field MUST be present.</t>

            <t></t>

            <t hangText="CertChain:">The signer's certificate chain, if any
            (see <xref target="sec.certificates"></xref>).</t>
          </list></t>

        <section anchor="sec.signature_computation"
                 title="Signature Computation">
          <t>The signature is computed over the string prior to base64
          encoding. I.e., the processing order for encoding is:</t>

          <t><list style="numbers">
              <t>Serialize the inner "Content" value into a string X.</t>

              <t>Compute the signature value over X. (In the case of
              signatures which use digests, this means feed the literal bytes
              of the signature into the digest function.). Insert the result
              into the "Signature" field.</t>

              <t>Compute the base64 representation of X and insert it into the
              "Value" field of the message.</t>
            </list></t>

          <t>This procedure removes dependencies on the exact serialization
          algorithm: variation in spacing, field order, etc. do not affect
          signature validity since the base64 representation preserves them on
          the wire and protects them from modification by intermediaries.</t>

          <t><list style="hanging">
              <t hangText="Note:">An alternative algorithm would be to compute
              the signature on the base64 representation itself, but this has
              two disadvantages: (1) any intermediaries which change
              spacing/line breaks would break the signature. (2) it is
              inconsistent with the algorithm for encryption (<xref
              target="sec.encrypted"></xref>), which is designed to avoid
              multiple base64 encoding.</t>
            </list></t>

          <t>This procedure only specifies the input to the signature
          computation. The details of the computation depend on the signature
          algorithm itself. The mapping from code points to algorithms is
          found in <xref target="sec.iana-cons"></xref>.</t>
        </section>

        <section anchor="sec.signature_verification"
                 title="Signature Verification">
          <t>In order to verify the signature, the steps of the previous
          section are reversed.</t>

          <t><list style="numbers">
              <t>Process the provided "Signer" and "CertChain" fields as
              described in <xref target="sec.certificates"></xref> in order to
              determine the sender's public key.</t>

              <t>Base64 decode the "Value" field in order to recover a string
              X.</t>

              <t>Verify the "Signature" field against X using the sender's
              public key and the "SignatureAlgorithm" and "DigestAlgorithm"
              fields. If the signature fails, return an error.</t>

              <t>Deserialize X to recover the inner "Content" value.</t>
            </list></t>

          <t></t>

          <section anchor="sec.certificates" title="Certificate Processing">
            <t>JSMS uses the "CertChain" element to carry certificate
            chains.</t>

            <figure>
              <!--begin-pdu-->

              <artwork><![CDATA[
var certchain_schema = {
  "description":"A certificate chain",
  "type":"object",
};

var certchain_pkix_schema = {
  "description":"A chain of PKIX certificates",
  "extends":certchain_schema,
  "properties":{
    "Type:{
      "description":"The type of certificate chain",
      "type":"string",
      "enum":["PKIX"] },
    "Chain":{
      "description":
      "PKIX certificates in order from root to end-entity",
      "type":"array",
      "items":{
        "description":"A base64-encoded BER certificate",
        "type":"string",
        }
}}};
               ]]></artwork>
            </figure>

            <t>The meaning of the fields is described below:</t>

            <t><list style="hanging">
                <t></t>

                <t hangText="Type:">The type of the certificate chain. The
                only defined value is "PKIX", referring to PKIX [REF]
                certificates.</t>

                <t></t>

                <t hangText="Chain:">An array of certificate values. In the
                case of "PKIX" certificates this is a list of base64-encoded
                DER/BER PKIX certificate values. PKIX certificates MUST be
                represented in order with each certificate certifying the next
                and the final certificate representing the end-entity.</t>
              </list></t>

            <t>The recipient MUST verify the certificate chain (in the case of
            PKIX certificates according to RFC 5280 <xref
            target="RFC5280"></xref>). If any validation failure occurs, the
            implementation MUST abort processing and return an error.</t>

            <t>Once the certificate chain is validated, the end-entity
            certificate must contain an identity which matches the "Signer"
            field. In the case of PKIX certificates, the certificate MUST
            contain a subjectAltName field of type
            "uniformResourceIdentifier". This field MUST be equivalent to the
            URI in the "Signer" field. If not, an error MUST be returned.</t>
          </section>
        </section>

        <section anchor="sec.signed-example" title="Example">
          <t>TODO</t>
        </section>
      </section>

      <section anchor="sec.encrypted" title="Encrypted Data">
        <t>An "encrypted" message contains an encrypted "Content" block. All
        "encrypted" messages contain a symmetric integrity check, either via a
        MAC or via an AEAD <xref target="RFC5116"></xref> algorithm such as
        GCM [REF]. A message may be encrypted to an arbitrary number of
        recipients. Each recipient is represented by a "Recipient" block,
        which contains a copy of the keying material encrypted for that
        recipient. Both symmetric and asymmetric key establishment is
        supported. In order to support both integrity and encryption, what is
        carried in the Recipient block is a Content Master Key (CMK) which is
        then used with a KDF to generate the Content Encryption Key (CEK) used
        to encrypt the message and the Content Integrity Key (CIK) used with
        the MAC.</t>

        <figure>
          <!--begin-pdu-->

          <artwork><![CDATA[
var encrypted_schema = {
  "description":"An encrypted object",
  "type":"object",
  "extends":message_schema,
  "properties":{
    "Recipients":{
      "description":"The list of recipient blocks",
      "type":"array",
      "items":{
         "description":"A single recipient block"
         "type":"recipient_schema",
       }
    },

    "KDF":{
      "description":
       "The KDF used to derive the MAC and encryption keys",
      "type":"string",
      "enum":["P_SHA256"]
    },
  
    "Encryption":{
      "description":
      "The encryption control information for the entire message",
      "type":"object",
      "properties":{
        "Algorithm":{
          "description":"The algorithm used to encrypt the message",
          "type":"string",
          "enum":["AES-128-CBC", "AES-256-CBC",
                  "AES-128-GCM", "AES-256-GCM"]
        }
        "IV":{
          "description":
          "The initialization vector for the message (base64)",
          "type":"string"
        } 
     }
    },
  
     "Integrity":{
      "description"
      "The integrity control information for the entire message",
      "type":"object",
      "properties":{
        "Algorithm":{
          "description":"The algorithm used to compute the MAC",
          "type":"string",
          "enum":["HMAC-SHA-256"],
        },
        "Value":{
          "description":"The MAC value (base64-encoded)",
          "type":"string",
        }
      }
    },

    "Data":{
      "description":"The ciphertext (base64-encoded)",
      "type":"string",
    }
  }
}
]]></artwork>
        </figure>

        <t>The meaning of the fields is as follows:</t>

        <t><list style="hanging">
            <t hangText="Recipients:">The list of recipients. This is an array
            of recipient_schema structures, each of which establishes the CMK
            for that recipient.</t>

            <t hangText="KDF:">Specifies the key derivation function used to
            generate the CEK and the CIK from the CMK. This field MAY be
            absent if an AEAD algorithm is used, in which case the CEK is
            derived by copying the CMK.</t>

            <t hangText="Encryption:">Specifies the properties of the
            encryption. The Algorithm field specifies the encryption algorithm
            and the IV field specifies the initialization vector (if required
            for the algorithm.</t>

            <t hangText="Integrity:">Specifies the properties of the integrity
            check. The Algorithm field specifies the MAC algorithm and the
            Value field contains the MAC. This field MAY be absent if no
            integrity check is used.</t>

            <t hangText="Data:">Contains the ciphertext.</t>
          </list></t>

        <t>Each Recipient element provides an encrypted copy of the CMK for a
        single recipient.</t>

        <figure>
          <!--begin-pdu-->

          <artwork><![CDATA[
var encrypted_schema = {
  "description":"An encrypted object",
  "type":"object",
  "extends":message_schema,
  "properties":{
    "KEK":{
      "type":"object",
      "description:"Identifies the key used to encrypt the CMK",
      "properties":{
        "RecipientName":{
         "type":"string",
         "description":
         "The recipients name represented as a URI",
        },
        "CertificateDigest":{
         "type":"string",
         "description":
         "A digest of the recipient's certificate",
  },
        "KeyIdentifier",
         "type":"string",
         "description":
         "An opaque string representing a shared symmetric key"
        }
      }
    },
    "Algorithm":{
      "description":"The algorithm used to protect the CMK",
      "type":"string",
      "enum":["RSA-PKCS1-1.5", "AES-128-CBC", 
      "AES-256-CBC", "AES-128-GCM", "AES-256-GCM"]
    },
    "Value":{
      "description":
      "The binary representation of the encrypted CMK (base64)",
      "type":string"
    }
  }
}
]]></artwork>
        </figure>

        <t>The meaning of the fields is described below:</t>

        <t><list style="hanging">
            <t></t>

            <t hangText="KEK">Indicates the key used to encrypt the CMK.
            Either a "RecipientName" or a "KeyIdentifier" MUST be provided. If
            the "RecipientName" is provided, then a "CertificateDigest" SHOULD
            be provided.</t>

            <t><list style="hanging">
                <t hangText="RecipientName:">Provides the recipient's name in
                URI form.</t>

                <t hangText="CertificateDigest:">[TODO: Canonicalization?
                TODO]</t>

                <t hangText="KeyIdentifier">The name of a shared symmetric key
                known to both sender and recipient. This need not be globally
                unique as long as it is unique within the recipient's
                context.</t>
              </list></t>

            <t hangText="Algorithm:">The algorithm used to encrypt the CMK.
            Note the JSMS only supports key transport and not key agreement
            (since key agreement can always be turned into key transport)
            [TODO - prev sentence does not make sense].</t>

            <t hangText="Value:">The CMK encrypted under the specified
            algorithm and key.</t>
          </list></t>

        <section anchor="sec.encryption" title="Message Encryption">
          <t>The message encryption process is as follows.</t>

          <t><list style="numbers">
              <t>Generate a random CMK. The CMK MUST have a length at least
              equal to that of the larger of the required integrity or
              encryption keys and MUST be generated randomly. See <xref
              target="RFC4086"></xref> for considerations on generating random
              values. [[ TODO - we need a section on generating randomness in
              browsers - it's easy to screw up ]]</t>

              <t>Encrypt the CMK for each recipient (see <xref
              target="sec.encrypt_cmk"></xref>)</t>

              <t>Generate a random IV (if required for the algorithm).</t>

              <t>Run the key derivation algorithm (see <xref
              target="sec.key_derivation"></xref>) to generate the CEK and CIK
              (if not using an AEAD algorithm).</t>

              <t>Serialize the content into a bitstring M.</t>

              <t>Encrypt M using the CEK and IV to form the bitstring C.</t>

              <t>Set the Value element equal to the base64-encoded
              representation of C.</t>

              <t>If not using an AEAD algorithm, compute the function I =
              MAC(CIK, C) using the chosen integrity algorithm. Note that this
              is EtA encryption which is considered the best cryptographic
              choice ([TODO: REF Canetti]). Set the Integrity.Value element
              equal to the base64-encoded representation of I.</t>
            </list></t>
        </section>

        <section anchor="sec.decryption" title="Message Decryption">
          <t>The message decryption process is the reverse of the encryption
          process.</t>

          <t><list style="numbers">
              <t>Identify a Recipient block which appears to reference a key
              known to the recipient.</t>

              <t>Decrypt the CMK. If this fails and another Recipient block
              appears plausible, that MAY be tried.</t>

              <t>Run the key derivation algorithm (see <xref
              target="sec.key_derivation"></xref>) to generate the CEK and CIK
              (if not using an AEAD algorithm).</t>

              <t>If not using an AEAD algorithm, compute the integrity check
              value I' on the binary representation of the Value element using
              the indicated integrity check. If the Integrity.Value does not
              match I', then an error MUST be reported and processing MUST be
              aborted.</t>

              <t>Decrypt the binary representation of the Value element and
              output the result</t>
            </list></t>
        </section>

        <section anchor="sec.key_derivation" title="Key Derivation">
          <t>The key derivation process converts the CMK into a CEK. It
          assumes as a primitive a Key Derivation Function (KDF) which
          notionally takes three arguments: <list style="hanging">
              <t hangText="MasterKey:">The master key used to compute the
              individual use keys</t>

              <t hangText="Label:">The use key label, used to differentiate
              individual use keys</t>

              <t hangText="Length:">The length of the desired use key</t>
            </list> The only real KDF specified in this document is the TLS
          PRF, which is invoked as PRF(MasterKey, Label) with an empty seed
          and produces an arbitrary length output. The appropriate number of
          bits (Length) is simply extracted from the beginning of the output.
          The KDF name "P_XXX" in this document refers the the TLS <xref
          target="RFC5246"></xref> PRF using P_XXX as the underlying P_hash
          function. [[ CJ - when I went to implimnet this, I could not figure
          out the seed stuff so some clarification of 5246 for implementors
          might be needed here ]]</t>

          <t>To compute the CEK from the CMK, the label "Encryption" is
          used.</t>

          <t>To compute the CIK from the CMK, the label "Integrity" is
          used.</t>

          <t>When AEAD algorithms are used the KDF element MUST not be
          present. When they are not used, it MUST be present.</t>
        </section>

        <section anchor="sec.encrypt_cmk" title="CMK Encryption">
          <t>JSMS supports two forms of CMK encryption:</t>

          <t><list style="symbols">
              <t>Asymmetric encryption under the recipient's public key.</t>

              <t>Symmetric encryption under a shared key.</t>
            </list></t>

          <section anchor="sec.asymmetric_encryption"
                   title="Asymmetric Encryption">
            <t>In the asymmetric encryption mode, the CMK is encrypted under
            the recipient's public key. The only currently defined asymmetric
            encryption mode is RSA-PKCS1-1.5, which refers to <xref
            target="RFC3447"></xref> RSAES-PKCS1-v1_5.</t>
          </section>

          <section anchor="sec.symmetric_encryption"
                   title="Symmetric Encryption">
            <t>In the symmetric encryption mode, the CMK is encrypted under a
            symmetric key shared between the sender and receiver. All such
            modes MUST provide integrity for the CMK. This document defines
            four such modes: AES-128-CBC, AES-256-CBC referring to the <xref
            target="RFC5649"></xref> AES key wrapping modes and AES-128-GCM,
            AES-256-GCM, referring to AES encryption with GCM. For GCM the
            random 64-bit IV is prepended to the ciphertext.</t>
          </section>
        </section>
      </section>

      <section anchor="sec.msg-composition" title="Composition">
        <t>This document does not specify a combination signed and encrypted
        mode. However, because the contents of a message can be arbitrary, and
        encryption and data origin authentication can be provided by
        recursively encapsulating multiple JSMS messages. In general, senders
        SHOULD sign the message and then encrypt the result (thus encrypting
        the signature). This prevents attacks in which the signature is
        stripped, leaving just an encrypted message, as well as providing
        privacy for the signer.</t>
      </section>
    </section>

    <section anchor="sec.iana-cons" title="IANA Considerations">
      <t>[TODO] <list style="symbols">
          <t>Register MIME types</t>

          <t>Registries for signature, encryption, MAC</t>

          <t>Well known HTTP URLs</t>
        </list></t>
    </section>

    <section title="Open Issues">
      <t>Reading the number of ways AEAD is handled differently, I don't want
      it.</t>
    </section>

    <section anchor="sec.sec-cons" title="Security Considerations"></section>

    <section title="XML Schemas for types"></section>

    <section title="Interoperabilty">
      <t>Can you take a CMS message you don't have the keys for and tear it
      apart and form a JSMS message and visa versa?</t>
    </section>

    <section title="Acknowledgments">
      <t>[TODO]</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &rfc2119;

      &rfc5280;

      &rfc5116;

      &rfc2045;

      &rfc4086;

      &rfc5246;

      &rfc3447;

      &rfc5649;
    </references>

    <references title="Informative References">
      &rfc3986;
    </references>
  </back>
</rfc>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:nil
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
