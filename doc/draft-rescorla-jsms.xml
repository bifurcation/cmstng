<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY rfc5116 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5116.xml">
<!ENTITY rfc2045 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY rfc3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY rfc4086 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml">
<!ENTITY rfc5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY rfc3447 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY rfc5649 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5649.xml">
]>
<!-- $Id -->
<?rfc inline="yes"?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="no" ?>
<!--<?rfc strict="yes" ?>-->
<?rfc compact="yes" ?>
<?rfc sortrefs="no" ?>
<?rfc colonspace='yes' ?>
<rfc category="std" docName="draft-rescorla-jsms-00.txt" 
     ipr="pre5378Trust200902">
  <front>
    <title abbrev="JSMS">JavaScript Message Security Format</title>

    <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
      <organization>Skype</organization>

      <address>
        <postal>
          <street>8000 Marina Blvd</street>

          <city>Brisbane</city>

          <region>CA</region>

          <code>94005</code>

          <country>USA</country>
        </postal>

        <email>ekr@skype.net</email>
      </address>
    </author>

    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <postal>
          <street>1899 Wyknoop Street, Suite 600</street>
          <city>Denver</city>
          <region>CO</region>
          <code>80202</code>
          <country>USA</country>
        </postal>
        <email>jhildebr@cisco.com</email>
      </address>
    </author>



    <date day="12" month="September" year="2010" />

    <abstract>
      <t>
         Many applications require the ability to send cryptographically
         secured messages. While the IETF has defined a number of formats
         for such messages [TODO: REF CMS, PEM, OpenPGP], those formats 
         use encodings which are not congenial for Web applications. 
         This document describes a new cryptographic message format
         which is based on JavaScript Object Notation (JSON) and thus
         is easy for Web applications to generate and parse.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
         Many applications require the ability to send cryptographically
         secured (encrypted, digitally signed, etc.) messages. 
         While the IETF has defined a number of formats for such messages
         [TODO: REF CMS, PEM, OpenPGP], those formats are widely
         viewed as being excessively complicated for the demands of
         Web applications, which typically only need the ability
         to secure simple messages. In addition, existing formats
         use encoding mechanisms (e.g., ASN.1) which are not congenial
         for Web applications. This presents an obstacle to the deployment
         of strong security by such applications.
      </t>
      <t>
         This document describes a new cryptographic message format,
         JavaScript Message Security (JSMS) intended to meet the need of the
         Web environment. While JSMS is modelled on existing
         formats--principally CMS [TODO: REF]--it uses JavaScript Object
         Notation (JSON) rather than ASN.1/BER/DER, making it far easier for
         Web applications to handle. In the interest of simplicity, JSMS also
         omits a number of lesser-used CMS modes (multiple signatures,
         password-based encryption).
      </t>
    </section>
    <section title="Conventions Used In This Document">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"> </xref>.</t>
    </section>
    <section title="Overview">
      <t>
         The JSMS message format is simply a JSON dictionary with an appropriate
         collection of fields. For instance, 
         [TODO: Need something here.]
      </t>
      <section title="Operational Modes">
         <t>
           JSMS supports two operational modes:
         </t><t>
           <list style="hanging">
             <t hangText="Encrypted Data"></t><t>
             A block of data encrypted under a random message encryption
             key (MEK). The MEK is then separately encrypted for each
             recipient, either via symmetric or asymmetric encryption.
             The data is always integrity protected, either via a
             separate MAC or an AEAD algorithm such as AES-GCM.</t>
             
             <t></t>

             <t hangText="Signed Data"></t><t>
             A block of data signed by a single signer using his
             asymmetric key and optionally carrying his certificate.
             Multiple signatures are not permitted (in our view,
             this feature has proved to be more trouble than it is
             generally worth.)
           </t>
           </list>
         </t>
         <t>
           Any other desired security functions are provided by composition
           of these modes. For instance, a signed and encrypted
           message is produced by first creating a Signed message and
           then encrypting that data. (See <xref target="sec.msg-composition"/> for more on composition.
         </t>
      </section>
      <section title="Conventions">
         <t>
           In general, JSMS follows the following structural conventions:
         </t>
         <t>
           <list style="hanging">
             <t hangText="Base64 as the only encoding"> </t>
             <t>
             Any data that does not have a straightforward string
             representation (binary values, large integers, etc.)
             is base64-encoded. In some cases, hexadecimal encodings
             might be more convenient, but consistency seems even
             more important.
             </t>

             <t></t>

             <t hangText="No canonicalization"></t>
             <t>
               In most cryptographic message formats (CMS, PKIX, 
               XML-DSIG [TODO: REF]), canonical encodings are 
               used to allow the same value to be computed at both
               sender and recipient (e.g., for digital signatures).
               This is inconvenient in
               JSON, which just views messages as a bundle of
               key/value pairs. Instead, whenever canonicalization
               would be required, the relevant data is serialized
               and base64 encoded for transport.
             </t>
             
             <t></t>

             <t hangText="In-memory processing"></t>
             <t>
               We assume that the entire message can fit in main
               memory and make no effort to design a wire representation
               which can be handled in small chunks in a single pass.
               This means, for instance, that there is no need to 
               have a message digest indicator at the beginning of
               the message and then the signature at the end, as
               is done in CMS. Fields are simply serialized in
               whatever order is most convenient for the JSON
               implementation. The examples in this document are
               generally shown in whatever order seems most readable and
               are not normative.
             </t>
           </list>
         </t>
         </section>

         <section title="Certificate Processing">
           <t>
             Experience has shown that certificate handling 
             path construction) is one of the trickier parts of
             building a cryptographic system. While JSMS supports
             PKIX certificates, its certificate processing
             is far simpler than that of CMS. 
             When a JSMS agent provides its certificate, it must
             provide an ordered chain (as in TLS [REF]) terminating
             in its own certificate, thus removing the need to construct
             certificate paths. In addition, because many implementations
             will not want to do any ASN.1/BER processing at all, 
             we define a Web service which applications can use for
             chain valiation. (See [TODO]).
           </t>
         </section>
      </section>

      
      <section title="Message Format">
         <section title="Content Object" anchor="sec.content">
	   <t>
	     JSMS operates by providing transformations on "Content" objects,
	     which are just mime-typed JSON objects. These objects are then
	     wrapped in a signed/encrypted wrapper:
	   </t>
	   <t>
	     [[OPEN ISSUE: Do we want to have both the schema description
	     and the bullet point description...]
	   </t>
	   <figure>
             <!--begin-pdu-->
	     
	     <artwork><![CDATA[
var content_schema={
          "description":"Message contents",
          "type":"object":
	  "properties":{
	             "ContentType":{
		                  "description":"A MIME content type",
				  "type":"string",
                     },
                     "Data":{
                                  "description":"The underlying data",
				  "type":"string",
		            }
}};
               ]]></artwork>
           </figure>
	   <t>
             The meaning of the fields is as follows:
	   </t>
          <t><list style="hanging">
              <t/>
      
               <t hangText="ContentType:">A MIME <xref target="RFC2045"/> media type indicating the 
	       type of the "Data" field.</t>
	       
	       <t hangText="Data:">The data value. [OPEN ISSUE: Do we need an encoding here?]</t>
	     </list>
	 </t>
	 <t>
	   Signing and encryption transform a "Content" object into 
	   "Signed" and "Encrypted" objects respectively. Verification and decryption
	   transform "Signed" and "Encrypted" objects back into "Content" objects.
	 </t>
         </section>
	 

         <section title="Common Elements" anchor="sec.message-common">
           <t>
             A JSMS message is simple a JSON dictionary object
             containing a set of specific values. 
           </t>

           <figure>
             <!--begin-pdu-->
	     <artwork><![CDATA[
var message_schema={
         "description":"The basic schema for a JSMS message",
         "type":"object",
         "properties":{
                  "Type":{
                           "description":"Message type",
                           "type":"string",
                           "enum":["signed", "encrypted"]
                  },
                  "Version":{
                           "description":"Version number for the message",
                           "type":"string",
                           "enum":["1.0"]
                  }
         }};
               ]]></artwork>
           </figure>
           
           <t>
             The following fields
             MUST be present in all messages:
           </t>
          <t><list style="hanging">
              <t/>
      
               <t hangText="Version:">The version number. For this specification
               this value MUST be set to the string "1.0". [TODO: VErsion processing.]</t>
               
               <t/>

               <t hangText="Type:">The type of the message. MUST be either
               "signed" or "encrypted", to indicate a signed message (<xref target="sec.signed"/>)
               or an encrypted message (<xref target="sec.encrypted"/>) respectively.</t>
             </list>
           </t>
           <t>
           </t>
         </section>

         <section title="Signed Data" anchor="sec.signed">
           <t>
             A "signed" message contains a signed data block plus a digital signature over
             that data. Only one signer is allowed.
           </t>

           <figure>
             <!--begin-pdu-->
              <artwork><![CDATA[
var signed_schema = {
         "description":"A signed message",
         "type":"object",
         "extends":message_schema,
         "properties":{
                  "Signature":{
                           "description":"The signature over the SignedData",
                           "type":"object",
                           "properties":{
                                    "Value":{
                                             "description":"the content to be signed",
                                             "type":"string"},
                                    "DigestAlgorithm":{
                                             "description":"",
                                             "type":"string",
                                             "enum":["SHA1", "SHA256"] },
                                    "SignatureAlgorithm":{
                                             "description":"",
                                             "type":"string",
                                             "enum":["RSA-PKCS1-1.5"] },
                                    "Signer":{
                                             "description":"",
                                             "type":"string",
                                             "format":"email" },
                                    "CertChain": {
                                        "description":"The signer's cert chain",
                                            "type":certchain_schema
                                             }
                           }}}};
               ]]></artwork>
           </figure>
	   <t>[[OPEN ISSUE: How do we represent enums that correspond to algorithm identifiers
	   and hence registries.]]</t>
	     
           <t>
             The meaning of the fields is described below:
           </t>
           <t>
             <list style="hanging">
               <t/><t hangText="Value:">The data over which the signature
               is computed. This value MUST be a base64-encoded version of
               a "Content" structure (see <xref target="sec.content"/>).
               [OPEN ISSUE: is this exactly what we want?]</t>
               
               <t/><t hangText="DigestAlgorithm:">The message digest used to
               compute the signature. This field MUST be present 
               for RSA-based signatures but MAY be omitted for future
               signatures which do not allow flexible digests.  </t>
               
               <t/><t hangText="SignatureAlgorithm:">The signature algorithm
               used to compute the signature. This field MUST be present.</t>

               <t/><t hangText="Signer:">The signer's identity, expressed
	       as a URI <xref target="RFC3986"/>
               This field MUST be present.
             </t>
             <t/><t hangText="CertChain:">The signer's certificate chain,
               if any (see <xref target="sec.certificates"/>).</t>
           </list>
           </t>
	   
	   <section title="Signature Computation" anchor="sec.signature_computation">
	     <t>
	       The signature is computed over the string prior to base64 encoding.
	       I.e., the processing order for encoding is:
	     </t>
	     <t><list style="numbers">
	       <t>Serialize the inner "Content" value into a string X.</t>
	       <t>Compute the signature value over X. (In the case of signatures
	       which use digests, this means feed the literal bytes of the
	       signature into the digest function.). Insert the result into
	       the "Signature" field.</t>
	       <t>Compute the base64 representation of X and insert it into
	       the "Value" field of the message.</t>
	     </list>
	     </t>
	     <t>
	       This procedure removes dependencies on the exact serialization
	       algorithm: variation in spacing, field order, etc. do not affect
	       signature validity since the base64 representation preserves them
	       on the wire and protects them from modification by intermediaries.
	     </t>
	     <t>
	       <list style="hanging">
		 <t hangText="Note:">
		   An alternative algorithm would be to compute the signature on the
		   base64 representation itself, but this has two disadvantages:
		   (1) any intermediaries which change spacing/line breaks would
		   break the signature. (2) it is inconsistent with the algorithm
		   for encryption (<xref target="sec.encrypted"/>), which is designed
		   to avoid multiple base64 encoding.
		 </t>
	       </list>
	     </t>
	     <t>
	       This procedure only specifies the input to the signature computation.
	       The details of the computation depend on the signature algorithm
	       itself. The mapping from code points to algorithms is found in
	       <xref target="sec.iana-cons"/>.
	     </t>
	   </section>
	   <section title="Signature Verification" anchor="sec.signature_verification">
	     <t>
	       In order to verify the signature, the steps of the previous section are
	       reversed. 
	     </t>
	     <t><list style="numbers">
	       <t>Process the provided "Signer" and "CertChain" fields
	       as described in <xref target="sec.certificates"/> in order to determine
	       the sender's public key.</t>
	       <t>Base64 decode the "Value" field in order to recover a string X.</t>
	       <t>Verify the "Signature" field against X using the sender's
	       public key and the "SignatureAlgorithm" and "DigestAlgorithm" fields.
	       If the signature fails, return an error.</t>
	       <t>Deserialize X to recover the inner "Content" value.</t>
	     </list>
	     </t>
	     <t>
	       
	     </t>
	     <section title="Certificate Processing" anchor="sec.certificates">
	       <t>
		 JSMS uses the "CertChain" element to carry certificate chains.
	       </t>
           <figure>
             <!--begin-pdu-->
	     <artwork><![CDATA[
var certchain_schema = {
         "description":"A certificate chain",
         "type":"object",
};

var certchain_pkix_schema = {
        "description":"A chain of PKIX certificates",
         "extends":certchain_schema,
         "properties":{
                 "Type:{
                       "description":"The type of certificate chain",
                       "type":"string",
                       "enum":["PKIX"] },
                  "Chain":{
                       "description":"PKIX certificates in order from root to end-entity",
                       "type":"array",
                       "items":{
                              "description":"A base64-encoded BER certificate",
                              "type":"string",
                               }
                               
}}};
               ]]></artwork>
           </figure>
           <t>
             The meaning of the fields is described below:
           </t>
           <t>
             <list style="hanging">
	       <t/><t hangText="Type:">The type of the certificate chain. The 
	       only defined value is "PKIX", referring to PKIX [REF] 
	       certificates.</t>
	       
	       <t/><t hangText="Chain:">An array of certificate values.
	       In the case of "PKIX" certificates this is a list of base64-encoded
	       DER/BER PKIX certificate values. PKIX certificates MUST be
	       represented in order with each certificate certifying the
	       next and the final certificate representing the end-entity.
	       </t>
	     </list>
	   </t>
	   <t>
	     The recipient MUST verify the certificate chain (in the case of
	     PKIX certificates according to RFC 5280 <xref target="RFC5280"/>). If any validation
	     failure occurs, the implementation MUST abort processing and
	     return an error.
	   </t>
	   <t>
	     Once the certificate chain is validated, the end-entity certificate must
	     contain an identity which matches the "Signer" field. In the case of
	     PKIX certificates, the certificate MUST contain a subjectAltName
	     field of type "uniformResourceIdentifier". This field MUST
	     be equivalent to the URI in the "Signer" field. If not,
	     an error MUST be returned.
	   </t>	   
	     </section>
	   </section>
	   <section title="Example" anchor="sec.signed-example">
	     <t>TODO</t>
	   </section>
	 </section>
	 <section title="Encrypted Data" anchor="sec.encrypted">
	   <t>
	     An "encrypted" message contains an encrypted "Content"
	     block. All "encrypted" messages contain a symmetric integrity check, either via a
	     MAC or via an AEAD <xref target="RFC5116"/> algorithm such as GCM
	     [REF].
	     A message may be encrypted to an arbitrary number of 
	     recipients. Each recipient is represented by a 
	     "Recipient" block, which contains a copy of the
	     keying material encrypted for that recipient.
	     Both symmetric and asymmetric key establishment 
	     is supported. In order to support both integrity and 
	     encryption, what is carried in the Recipient block 
	     is a Content Master Key (CMK) which is then used with
	      a KDF to generate the Content Encryption Key (CEK)
	      used to encrypt the message and the Content Integrity Key (CIK) used with the MAC.
	   </t>
           <figure>
             <!--begin-pdu-->
              <artwork><![CDATA[
var encrypted_schema = {
  "description":"An encrypted object",
  "type":"object",
  "extends":message_schema,
  "properties":{
    "Recipients":{
      "description":"The list of recipient blocks",
      "type":"array",
      "items":{
         "description":"A single recipient block"
         "type":"recipient_schema",
       }
    },

    "KDF":{
      "description":"The KDF used to derive the MAC and encryption keys",
      "type":"string",
      "enum":["P_SHA256"]
    },
  
    "Encryption":{
      "description":"The encryption control information for the entire message",
      "type":"object",
      "properties":{
        "Algorithm":{
          "description":"The algorithm used to encrypt the message",
          "type":"string",
          "enum":["AES-128-CBC", "AES-256-CBC", "AES-128-GCM", "AES-256-GCM"]
        }
        "IV":{
          "description":"The initialization vector for the message (base64-encoded)",
	  "type":"string"
        } 
     }
    },
  
     "Integrity":{
      "description":"The integrity control information for the entire message",
      "type":"object",
      "properties":{
        "Algorithm":{
          "description":"The algorithm used to compute the MAC",
          "type":"string",
          "enum":["HMAC-SHA-256"],
        },
        "Value":{
          "description":"The MAC value (base64-encoded)",
          "type":"string",
        }
      }
    },

    "Data":{
      "description":"The ciphertext (base64-encoded)",
      "type":"string",
    }
  }
}
]]></artwork>
	   </figure>

	   <t>
             The meaning of the fields is as follows:
	   </t>
          <t><list style="hanging">
	      
	    <t></t><t hangText="Recipients:">
	    The list of recipients. This
	    is an array of recipient_schema structures, each of 
	    which establishes the CMK for that recipient.</t>
	    
	    <t></t><t hangText="KDF:">
	    Specifies the key derivation function used to generate
	    the CEK and the CIK from the CMK. This field MAY
	    be absent if an AEAD algorithm is used, in which 
	    case the CEK is derived by copying the CMK.</t>
	    
	    <t></t>><t hangText="Encryption:">
	    Specifies the properties of the encryption. The Algorithm
	    field specifies the encryption algorithm and the IV field
	    specifies the initialization vector (if required for the
	    algorithm.</t>
	    
	    <t></t>><t hangText="Integrity:">
	    Specifies the properties of the integrity check. The
	    Algorithm field specifies the MAC algorithm and the
	    Value field contains the MAC. This field MAY be absent
	    if no integrity check is used.</t>

	    <t></t><t hangText="Data:">
	    Contains the ciphertext.</t>
	  </list>
	  </t>
	  
	  <t>
	    Each Recipient element provides an encrypted copy of the CMK 
	    for a single recipient.
	  </t>
           <figure>
             <!--begin-pdu-->
              <artwork><![CDATA[
var encrypted_schema = {
  "description":"An encrypted object",
  "type":"object",
  "extends":message_schema,
  "properties":{
    "KEK":{
      "type":"object",
      "description:"Identifies the key used to encrypt the CMK",
      "properties":{
        "RecipientName":{
         "type":"string",
	 "description":"The recipients name represented as a URI",
        },
        "CertificateDigest":{
         "type":"string",
	 "description":"A digest of the recipient's certificate",
	},
        "KeyIdentifier",
         "type":"string",
	 "description":"An opaque string representing a shared symmetric key"
        }
      }
    },
    "Algorithm":{
      "description":"The algorithm used to protect the CMK",
      "type":"string",
      "enum":["RSA-PKCS1-1.5", "AES-128-CBC", "AES-256-CBC", "AES-128-GCM", "AES-256-GCM"]
    },
    "Value":{
      "description":"The binary representation of the encrypted CMK (base64-encoded)",
      "type":string"
    }
  }
}
]]></artwork>
</figure>
           <t>
             The meaning of the fields is described below:
           </t>
           <t>
             <list style="hanging">
	       <t/><t hangText="KEK">Indicates the key used to encrypt
	       the CMK. Either a "RecipientName" or a "KeyIdentifier" 
	       MUST be provided. If the "RecipientName" is provided, then
	       a "CertificateDigest" SHOULD be provided.</t>
	       <t></t>
	       
	       <list style="hanging">
		 <t hangText="RecipientName:">Provides the recipient's name in URI
		 form.</t>
		 
		 <t hangText="CertificateDigest:">[TODO: Canonicalization? TODO]</t>
		 
		 <t hangText="KeyIdentifier">The name of a shared symmetric key 
		 known to both sender and recipient. This need not be globally
		 unique as long as it is unique within the recipient's context.</t>
	       </list>
	       
	       <t hangText="Algorithm:">The algorithm used to encrypt the CMK. Note
	       the JSMS only supports key transport and not key agreement
	       (since key agreement can always be turned into key transport).
	       </t>
	       
	       <t hangText="Value:">The CMK encrypted under the specified algorithm
	       and key.</t>
	     </list>
	   </t>
	   
	   <section title="Message Encryption" anchor="sec.encryption">
	     <t>
	       The message encryption process is as follows.
	     </t>
	     <t><list style="numbers">
	       <t>Generate a random CMK. The CMK MUST have a length at least
	       equal to that of the larger of the required integrity or
	       encryption keys and MUST be generated randomly. See <xref target="RFC4086"/>
	       for considerations on generating random values.</t>

	       <t>Encrypt the CMK for each recipient (see <xref target="sec.encrypt_cmk"/>)</t>

	       <t>Generate a random IV (if required for the algorithm).</t>
	       
	       <t>Run the key derivation algorithm (see <xref target="sec.key_derivation"/>)
	       to generate the CEK and CIK (if not using an AEAD algorithm).</t>

	       <t>Serialize the content into a bitstring M.</t>
	       
	       <t>Encrypt M using the CEK and IV to form the bitstring C.</t>

	       <t>Set the Value element equal to the base64-encoded representation of C.</t>
	       
	       <t>If not using an AEAD algorithm, compute the function I = MAC(CIK, C)
	       using the chosen integrity algorithm. Note that this is EtA encryption
	       which is considered the best cryptographic choice ([TODO: REF Canetti]).
	       Set the Integrity.Value element equal to the base64-encoded representation of I.</t>
	       
	       </list>
	     </t>
	   </section>
	   <section title="Message Decryption" anchor="sec.decryption">
	     <t>
	       The message decryption process is the reverse of the encryption process.
	     </t>
	     <t><list style="numbers">
	       <t>Identify a Recipient block which appears to reference a key known to the recipient.</t>
	       
	       <t>Decrypt the CMK. If this fails and another Recipient block appears plausible,
	       that MAY be tried.</t>

	       <t>Run the key derivation algorithm (see <xref target="sec.key_derivation"/>)
	       to generate the CEK and CIK (if not using an AEAD algorithm).</t>
	       
	       <t>If not using an AEAD algorithm, compute the integrity check value I' on the
	       binary representation of the Value element using the indicated integrity
	       check. If the Integrity.Value does not match I', then an error MUST be reported
	       and processing MUST be aborted.</t>

	       <t>Decrypt the binary representation of the Value element and output the result</t>
	     </list>
	     </t>
	   </section>
	   

	   <section title="Key Derivation" anchor="sec.key_derivation">
	     <t>
	       The key derivation process converts the CMK into a CEK. It assumes as
	       a primitive a Key Derivation Function (KDF) which notionally
	       takes three arguments:

	       <list style="hanging">
		 <t hangText="MasterKey:">The master key used to compute the individual use keys</t>
		 <t hangText="Label:">The use key label, used to differentiate individual use keys</t>
		 <t hangText="Length:">The length of the desired use key</t>
	       </list>
	       
	       <t>
		 The only real KDF specified in this document is the TLS PRF, which is invoked
		 as PRF(MasterKey, Label) with an empty seed and produces an arbitrary length
		 output. The appropriate number of bits (Length) is simply extracted from the beginning
		 of the output. The KDF name "P_XXX" in this document refers the the 
		 TLS <xref target="RFC5246"/> PRF using P_XXX as the underlying P_hash function.
	       </t>
	       
	       <t>
		 To compute the CEK from the CMK, the label "Encryption" is used.
	       </t>
	       
	       <t>
		 To compute the CIK from the CMK, the label "Integrity" is used.
	       </t>

	       <t>
		 When AEAD algorithms are used the KDF element MUST not be present.
		 When they are not used, it MUST be present.
	       </t>
	     </t>
	   </section>
	   <section title="CMK Encryption" anchor="sec.encrypt_cmk">
	     <t>
	       JSMS supports two forms of CMK encryption:
	     </t>
	     <t>
	       <list style="symbols">
		 <t>Asymmetric encryption under the recipient's public key.</t>
		 <t>Symmetric encryption under a shared key.</t>
	       </list>
	     </t>
	     <section title="Asymmetric Encryption" anchor="sec.asymmetric_encryption">
	       <t>
		 In the asymmetric encryption mode, the CMK is encrypted under the 
		 recipient's public key. The only currently defined asymmetric encryption
		 mode is RSA-PKCS1-1.5, which refers to <xref target="RFC3447"/> 
		 RSAES-PKCS1-v1_5.
	       </t>
	     </section>
	     <section title="Symmetric Encryption" anchor="sec.symmetric_encryption">
	       <t>
		 In the symmetric encryption mode, the CMK is encrypted under a
		 symmetric key shared between the sender and receiver. All such
		 modes MUST provide integrity for the CMK. This document defines
		 four such modes: AES-128-CBC, AES-256-CBC
		 referring to the <xref target="RFC5649"/> AES key wrapping
		 modes and AES-128-GCM, AES-256-GCM, referring to AES encryption
		 with GCM. For GCM the random 64-bit IV is prepended to the ciphertext.
	       </t>
	     </section>
	   </section>
         </section>

         <section title="Composition" anchor="sec.msg-composition">
	   <t>
	     This document does not specify a combination signed and encrypted
	     mode. However, because the contents of a message can be arbitrary,
	     and encryption and data origin authentication can be provided by
	     recursively encapsulating multiple JSMS messages. In general,
	     senders SHOULD sign the message and then encrypt the result
	     (thus encrypting the signature). This prevents attacks in which the
	     signature is stripped, leaving just an encrypted message, as
	     well as providing privacy for the signer.
	   </t>
         </section>
      </section>
      
      <section title="IANA Considerations" anchor="sec.iana-cons">
         <t>
           [TODO]
           <list style="symbols">
             <t>Register MIME types</t>
             <t>Registries for signature, encryption, MAC</t>
           </list>
         </t>
           
      </section>

      <section title="Security Considerations" anchor="sec.sec-cons">

      </section>

    <section title="Acknowledgments">
    <t>
      [TODO]
    </t>
    </section>
  </middle>
  
  <back>
    <references title="Normative References">
      &rfc2119;
      &rfc5280;
      &rfc5116;
      &rfc2045;
      &rfc3986;
      &rfc4086;
      &rfc5246;
      &rfc3447;
      &rfc5649;
    </references>
    <references title="Informative References">
    </references> 
  </back>
</rfc>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:nil
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

