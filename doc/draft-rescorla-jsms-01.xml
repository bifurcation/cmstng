<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2045 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc3339 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml">
<!ENTITY rfc3447 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY rfc3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY rfc4086 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml">
<!ENTITY rfc4627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY rfc4648 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY rfc5116 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5116.xml">
<!ENTITY rfc5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY rfc5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY rfc5649 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5649.xml">
<!ENTITY rfc5652 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5652.xml">
<!ENTITY webfinger SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-hammer-webfinger-00.xml">
<!ENTITY jsonschema SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-zyp-json-schema-03.xml">
]>
<!-- $Id -->
<?rfc inline="yes"?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="no" ?>
<?rfc colonspace='yes' ?>
<rfc category="std" docName="draft-rescorla-jsms-00.txt" ipr="trust200902">
  <front>
    <title abbrev="JSMS">JavaScript Message Security Format</title>

    <author fullname="Richard Barnes" initials="R." surname="Barnes">
      <organization>BBN Technologies</organization>

      <address>
        <postal>
          <street>1300 N. 17th St.</street>

          <city>Arlington</city>

          <region>VA</region>

          <code>22209</code>

          <country>USA</country>
        </postal>

        <email>rbarnes@bbn.com</email>
      </address>
    </author>

    <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
      <organization>RTFM, Inc.</organization>

      <address>
        <postal>
          <street>2064 Edgewood Drive</street>

          <city>Palo Alto</city>

          <region>CA</region>

          <code>94303</code>

          <country>USA</country>
        </postal>

        <email>ekr@rtfm.com</email>
      </address>
    </author>

    <author fullname="Joe Hildebrand" initials="J." surname="Hildebrand">
      <organization>Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>1899 Wyknoop Street, Suite 600</street>

          <city>Denver</city>

          <region>CO</region>

          <code>80202</code>

          <country>USA</country>
        </postal>

        <email>jhildebr@cisco.com</email>
      </address>
    </author>

    <date day="1" month="July" year="2011"/>

    <abstract>
      <t>Many applications require the ability to send cryptographically
      secured messages. While the IETF has defined a number of formats for
      such messages (e.g. CMS) those formats use encodings which are not
      congenial for Web applications. This document describes a new
      cryptographic message format which is based on JavaScript Object
      Notation (JSON) and thus is easy for Web applications to generate and
      parse.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Many applications require the ability to send cryptographically
      secured (encrypted, digitally signed, etc.) messages. While the IETF has
      defined a number of formats for such messages, those formats are widely
      viewed as being excessively complicated for the demands of Web
      applications, which typically only need the ability to secure simple
      messages. In addition, existing formats use encoding mechanisms (e.g.,
      ASN.1 BER/DER) which are not congenial for Web applications. This
      presents an obstacle to the deployment of strong security by such
      applications.</t>

      <t>This document describes a new cryptographic message format,
      JavaScript Message Security (JSMS) intended to meet the need of the Web
      environment. While JSMS is modeled on existing formats -- principally
      CMS <xref target="RFC5652"/> -- it uses JavaScript Object Notation
      (JSON) rather than ASN.1/BER/DER, making it far easier for Web
      applications to handle. In the interest of simplicity, JSMS also omits
      as many as possible of the CMS modes (multiple signatures,
      password-based encryption).</t>
    </section>

    <section title="Conventions Used In This Document">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"/>.</t>

      <t>[Notes on Base64 encoding]</t>
    </section>

    <section title="Overview">
      <t>The JSMS message format is simply a JSON <xref target="RFC4627"/>
      dictionary with an appropriate collection of fields. Each operating mode
      will have a separate set of fields, with a common field to distinguish
      between the modes.</t>

      <section title="Operational Modes">
        <t>JSMS supports two operational modes:</t>

        <t><list style="hanging">
            <t hangText="Encrypted Data"/>

            <t>A block of data encrypted under a random message encryption key
            (MEK). The MEK is then separately encrypted for each recipient,
            either via symmetric or asymmetric encryption. The data is always
            integrity protected, either via a separate Message Authentication
            Code (MAC) or an Authenticated Encryption with Associated Data
            (AEAD) algorithm such as AES-GCM or AES-CCM.</t>

            <t hangText="Signed Data"/>

            <t>A block of data signed by a single signer using his asymmetric
            key and optionally carrying his certificate. Multiple signatures
            are not permitted in order to keep things simple.</t>
          </list></t>

        <t>Any other desired security functions are provided by composition of
        these modes. For instance, a signed and encrypted message is produced
        by first creating a Signed message and then encrypting that data.</t>
      </section>

      <section title="Conventions">
        <t>In general, JSMS follows the following structural conventions:</t>

        <t><list style="hanging">
            <t hangText="Minimize implementation complexity"/>

            <t>Wherever possible, protocol choices have been made such that
            the time and effort required to implement the protocol in many
            different programming languages will be minimized. This means that
            optimizations for bandwidth, CPU, and memory utilization have been
            explicitly avoided.</t>

            <t hangText="Base64 as the only encoding"/>

            <t>Any data that does not have a straightforward string
            representation (binary values, large integers, etc.) is
            base64-encoded (see: <xref target="RFC4648"/>). In some cases,
            hexadecimal encodings might be more convenient, but consistency is
            even more important to reduce implementation complexity.</t>

            <t hangText="No canonicalization"/>

            <t>In many cryptographic message formats, canonical encodings are
            used to allow the same value to be computed at both sender and
            recipient (e.g., for digital signatures). This is inconvenient in
            JSON, which just views messages as a bundle of key/value pairs.
            Instead, whenever canonicalization would be required, the relevant
            data is serialized and base64-encoded for transport, allowing both
            sides to run computations over the same original set of
            octets.</t>

            <t hangText="In-memory processing"/>

            <t>We assume that the entire message can fit in main memory and
            make no effort to design a wire representation which can be
            handled in small chunks in a single pass. This means, for
            instance, that there is no need to have a message digest indicator
            at the beginning of the message and then the signature at the end,
            as is done in CMS. Fields are simply serialized in whatever order
            is most convenient for the JSON implementation. The examples in
            this document are generally shown in whatever order seems most
            readable and are not normative.</t>
          </list></t>
      </section>

      <section title="Certificate Processing">
        <t>Experience has shown that certificate handling (path construction)
        is one of the trickier parts of building a cryptographic system. While
        JSMS supports PKIX certificates, its certificate processing is far
        simpler than that of CMS. When a JSMS agent provides its certificate,
        it must provide an ordered chain (as in TLS <xref target="RFC5246"/>)
        terminating in its own certificate, thus removing the need to
        construct certificate paths. The certificates MUST be ordered with the
        end-entity certificate first and each certificate that follows signing
        the certificate immediately preceding it. In addition, because many
        implementations will not want to do any ASN.1/BER processing at all,
        we will define a Web Service which applications can use for chain
        validation and translation to an easy-to-parse format. (See
        [TODO]).</t>
      </section>

      <section title="Certificate Discovery">
        <t>JSMS will often be used in an online messaging environment with
        users that have an address of the form user@domain, such as email,
        XMPP, or SIP. As such, protocols such as WebFinger <xref
        target="I-D.hammer-webfinger"/> or an end-to-end protocol can be used
        to retrieve appropriate certificates. Downstream uses of JSMS SHOULD
        define a discovery mechanism suitable for the intended use.</t>
      </section>
    </section>

    <section title="Message Format">
      <t>A JSMS object is a JSON dictionary that encodes cryptographic
      informaton related to a content byte string. This document specifies the
      set of keys that must be present in a JSMS object, and what the
      associated values are. In general, these keys are chosen to be short but
      mnemonic, in order to minimize the size of JSMS objects while still
      being easy to use. In processing JSMS objects, unknown dictionary keys
      MUST be ignored.</t>

      <t>JSMS defines three top-level types of secure object, each of which
      provides a specific cryptographic protection to a byte string.<list
          style="hanging">
          <t hangText="SignedData:">Signature using a public-key digital
          signature algorithm</t>

          <t hangText="AuthenticatedData:">Authentication using a Message
          Authentication Code (MAC)</t>

          <t hangText="EncryptedData:">Encryption and authentication using an
          Authenticated Encryption with Associated Data (AEAD) algorithm</t>
        </list></t>

      <section title="Data types">
        <t>For each field in a JSON object, we define the type of information
        that must be included in that field. At base are the object, array,
        string, number types defined by JSON. We also use two special
        sub-classes of strings: Fields with type "token" contain a string
        drawn from an IANA registry of strings (e.g., for algorithm
        identifiers). Fields with type "bytes" contain a Base64-encoded byte
        string (note the considerations related to Base64 encoding in Section
        [[REF]] above).</t>

        <t>In addition to the primitive data types, Section [[REF]] defines a
        collection of useful object types that are used by the top-level JSMS
        objects. These are simply referred to by name when they appear as a
        field value in another object.</t>

        <t>[[ TODO: For TOKEN values, define what registry they should be
        drawn from ]]</t>
      </section>

      <section title="Common Elements">
        <t>The following elements are common to all JSMS messages:<list
            style="hanging">
            <t hangText="&quot;v&quot;:">REQUIRED NUMBER The version of JSMS
            used by this object. This field MUST be set to 1.</t>

            <t hangText="&quot;t&quot;:">REQUIRED TOKEN The type of this JSMS
            object. This field MUST be set to one of the following values<list
                style="hanging">
                <t hangText="&quot;s&quot;:">SignedData object</t>

                <t hangText="&quot;a&quot;:">AuthenticatedData object</t>

                <t hangText="&quot;e&quot;:">EncryptedData object</t>
              </list></t>

            <t hangText="&quot;c&quot;:">OPTIONAL BYTES The content byte
            string, Base64-encoded.</t>
          </list>If the "c" key is not present in a given JSMS object, then
        the JSMS object is "detached". In this case, the content must be
        associated with the JSMS object through some out-of-band mechanism
        before the JSMS object can be processed.</t>

        <t>[[ Q: Should we include an option to have a URI pointing to
        content? ]]</t>
      </section>

      <section title="SignedData">
        <t>A SignedData object MUST have a "t" field set to "s". In addition,
        a SignedData object contains the following keys:<list style="hanging">
            <t hangText="&quot;da&quot;:">REQUIRED AlgorithmIdentifier The
            digest algorithm used in signing the content. [[ IANA note ]]</t>

            <t hangText="&quot;sa&quot;:">REQUIRED AlgorithmIdentifier The
            signature algorithm used in signing the content [[ IANA note
            ]]</t>

            <t hangText="&quot;s&quot;:">REQUIRED BYTES The Base64-encoded
            signature value</t>

            <t hangText="&quot;k&quot;:">REQUIRED PublicKey The public key
            identifier for the signer, represented as a PublicKey object (see
            below)</t>

            <t hangText="&quot;c&quot;:">OPTIONAL ARRAY A certificate chain
            associating the signer's public key with an identifier. Each
            element in the array is a string containing the Base64-encoded
            representation of a DER-formatted certificate. The certificates
            MUST be ordered with the end-entity certificate first and each
            certificate that follows signing the certificate immediately
            preceding it.</t>
          </list></t>

        <t>[[ Q: Include an option to include a URI pointing to a cert/chain?
        ]]</t>

        <t>[[ How to generate the signature =
        http://tools.ietf.org/html/rfc5652#section-5.4 and
        http://tools.ietf.org/html/rfc5652#section-5.5 ]]</t>

        <t>[[ How to verify the signature =
        http://tools.ietf.org/html/rfc5652#section-5.6 ]]</t>
      </section>

      <section title="AuthenticatedData">
        <t>An AuthenticatedData object MUST have a "t" field set to "a". In
        addition, an AuthenticatedData object contains the following
        keys:<list style="hanging">
            <t hangText="&quot;a&quot;:">REQUIRED AlgorithmIdentifier The MAC
            algorithm used to authenticate the content.</t>

            <t hangText="&quot;m&quot;:">REQUIRED BYTES The MAC value</t>

            <t hangText="&quot;k&quot;:">REQUIRED ARRAY Wrapped versions of
            the symmetric key used for this MAC. Each element in the array
            MUST be a WrappedSymmetricKey object (see below).</t>
          </list></t>

        <t>[[ How to generate the MAC ==
        http://tools.ietf.org/html/rfc5652#section-9.2 with no
        attributes]]</t>

        <t>[[ How to verify the MAC ==
        http://tools.ietf.org/html/rfc5652#section-9.3 with no attributes
        ]]</t>
      </section>

      <section title="EncryptedData">
        <t>An EncryptedData object MUST have a "t" field set to "e". Note also
        that in an EncryptedData object, the "c" field contains the encrypted
        form of the content, not the content itself (as plaintext). An
        EncryptedData object contains the following keys in addition to any
        common fields:<list style="hanging">
            <t hangText="&quot;a&quot;:">REQUIRED AlgorithmIdentifier The
            encryption algorithm used to encrypt the content</t>

            <t hangText="&quot;k&quot;:">REQUIRED ARRAY Wrapped versions of
            the symmetric key used to encrypt the content. Each element in the
            array MUST be a WrappedSymmetricKey object (see below).</t>
          </list></t>

        <t>[[ How to encrypt ==
        http://tools.ietf.org/html/rfc5652#section-6.3]]</t>

        <t>[[ How to decrypt? Don't think this is necessary ]]</t>
      </section>

      <section title="Useful Objects">
        <t>In this section we define some common object types that are used
        across the top-level objects above.</t>

        <section title="AlgorithmIdentifier">
          <t>An AlgorithmIdentifier object names a cryptographic algorithm and
          specifies any associated parameters. If the algorithm has no
          parameters, then it the AlgorithmIdentifier object is simply a token
          represnting the name of the algorithm. [[ Note about registries
          ]]</t>

          <t>If the algorithm specifies parameters, the AlgorithmIdentifier
          object is an array. The first entry in the array is a token
          represnting the name of the algorithm. Any subsequent entries are
          defined by the algorithm.</t>

          <t>[[ TODO: Define any algorithms we need, or point to external
          document ]]</t>

          <t>[[ Note: Only AEAD encryption algorithms allowed. If you want to
          use a non-AEAD algorithm, add an HMAC and use
          draft-mcgrew-aead-aes-cbc-hmac-sha1]]</t>

          <t>Examples:<list style="empty">
              <t>"rsa"</t>

              <t>"hmac-sha1"</t>

              <t>["aes128-cbc", "gPOe6qFL5W7Mhg9ODBLoZg=="]</t>

              <t>["aead-gen", "aes128-cbc", "hmac-sha1", { "iv":
              "gPOe6qFL5W7Mhg9ODBLoZg==", "n": "0rlhQLrieXchGYbnxxkySg=="
              }],</t>
            </list></t>
        </section>

        <section title="PublicKey">
          <t>A PublicKey object describes the public key used by a signer. The
          key may be specified as a JSON structure, as a URI, or as an
          identifier.</t>

          <t>If the key is specified directly, then the PublicKey object MUST
          be an array. The first entry in the array is an AlgorithmIdentifier
          object identifying the algorithm with which the key is to be used.
          Subsequent entries in the array specify the elements of the key, in
          a manner determined by the algorithm.</t>

          <t>[[ Format for RSA keys, ["rsa",n,e] ]]</t>

          <t>[[ Format for ECC keys, TBD ]]</t>

          <t>If the key is referenced by an opaque identifier or
          "fingerprint", then the PublicKey object is a two-element JSON
          array. The first element is the token "id", and the second element
          is the SHA-1 hash of the public key, represented as a DER-encoded
          subjectPublicKeyInfo data structure. (This fingerprint format is the
          same as the one included in the subjectKeyIdentifier field in an
          X.509 certificate.)</t>

          <t>If the key is provided as a URI, then the PublicKey object MUST
          be a string containing a URI where the key can be retrieved, either
          in the JSON format described above, or in a DER-encoded PKIX
          certificate. The method that the recipient of a JSMS object uses to
          retrieve the key will depend on the URI scheme. For HTTP URIs, the
          relying party MUST issue an HTTP request with the GET method and an
          Accept header including the MIME type for JSMS PublicKey object,
          "[[MIMETYPE]]". For MAILTO, SIP, and XMPP URIs, the recipient MAY
          use the WebFinger protocol [[REF]] to retrieve a public key for the
          user.</t>

          <t>[[ Q: Should we also allow a fingerprint based on the JSON
          structure above? Would need to canonicalize it somehow. ]]</t>

          <t>Examples: <list style="empty">
              <t>["rsa",
              9873955694194590232514048984970761535584766520827432398848323179877576914413107050563833143580841040071254924123181885362208552200375950092400886745004251,
              3]</t>

              <t>["id", "i1LbR8FCEw-aiFcAAfUvpp75wdY="]</t>

              <t>"http://example.com/user23/publickey.jsms"</t>

              <t>"xmpp:juliet@example.com"</t>
            </list></t>
        </section>

        <section title="WrappedSymmetricKey">
          <t>In JSMS objects that use symmetric keys (for MAC or encryption),
          it is necessary for the originator to convey the symmetric key used
          for in JSMS computations to the recipient. The WrappedSymmetricKey
          object is a JSON object that allows these keys to be provided either
          using key transport or key agreement. The following fields may be
          present in a WrappedSymmetricKey object:<list style="hanging">
              <t hangText="&quot;t&quot;:">REQUIRED TOKEN The type of wrapping
              being done. This document defines the following two values for
              this field:<list style="hanging">
                  <t hangText="&quot;s&quot;:">Symmetric key transport. The
                  "i" field MUST be present. Any other non-required fields are
                  ignored.</t>

                  <t hangText="&quot;p&quot;:">Asymmetric key transport. The
                  "p" field MUST be present. Any other non-required fields are
                  ignored.</t>

                  <t hangText="&quot;a&quot;:">Key agreement. The "o" and "r"
                  MUST be present, and the "u" field MAY be present. Any other
                  non-required fields are ignored.</t>
                </list></t>

              <t hangText="&quot;a&quot;:">REQUIRED AlgorithmIdentifier The
              algorithm used to encrypt the symmetric key</t>

              <t hangText="&quot;k&quot;:">REQUIRED BYTES The symmetric key,
              encrypted according to the algorithm indicated by the "a"
              value</t>

              <t hangText="&quot;i&quot;:">OPTIONAL BYTES An opaque identifier
              for the symmtric key encryption key</t>

              <t hangText="&quot;i&quot;:">OPTIONAL PublicKey The public key
              used to wrap the symmetric key</t>

              <t hangText="&quot;o&quot;:">OPTIONAL PublicKey The public key
              of the originator</t>

              <t hangText="&quot;r&quot;:">OPTIONAL PublicKey The public key
              of the recipient</t>

              <t hangText="&quot;u&quot;:">OPTIONAL BYTES User key
              material</t>
            </list></t>

          <t>[[ How to perform wrapping/unwrapping ]]</t>
        </section>
      </section>
    </section>

    <section title="Examples">
      <t>This section contains complete examples of all three JSMS types.</t>

      <section title="Parameters">
        <t/>

        <figure>
          <artwork><![CDATA[RSA key:
n = 12237824263694976709651031408224222555291991012810482177
    92035786941828977156926971807863278433272099745881797299
    85336687220073096675483822073402642772681280616976104546
    17255329475427018303562916009664448746047222690146365929
    82951349410567289583328152613883921620510403508194065665
    63967272795487285560945461681
d = 75878357104421224437595505023603656489355639532714946259
    33346690019564595079379205549922077473184883832629939313
    60018964125252953813614463578240747832202105107893654165
    79392505080998449581120603587386341503989723156683831337
    82007353216712737164755944535635260836679769708872556214
    3293140567116070641632520193
e = 65537

Key Tag:       01f47ad049e8b81b05f32825a988cd5212ce781e
Key Encryption Key:    4A5055F46000455098EFBF40EF23752B
AuthenticatedData Key: b55b250062b6eb0cfdfa1606beb76491
                       39a738395c8f777a526305b65a78dae1
EncryptedData Key (E): 6abb9bc1e7dd54dde7845b682a2cd183
EncryptedData Key (A): 2612b158a27efde93309ea12dcb0b047
                       8e0c2bbc35eff0cf3bd974e1797d6fc2 

Content:
"Attack at dawn!"
]]></artwork>
        </figure>
      </section>

      <section title="SignedData">
        <t>In this object the content is signed under the specified RSA key
        pair, using SHA1 as the digest.</t>

        <figure>
          <artwork><![CDATA[{
    "v": 1,
    "t": "s",
    "c": "QXR0YWNrIGF0IGRhd24h",
    "da": "sha1",
    "sa": "pkcs1"
    "s": "FTzVmWfkW5Lajck73of7y9zbYj3k5ok34mKIteVpkalzx9ILAi
        luMngBJJZPQdm2R_CqdH8Vfqxfuplj0w4XplfO3xcCZfS3L8bnoE
        mHvXI9a3Wii_2dCnBg6xl8456xOUors2dCQS7kjlbPdeYe2BEOom
        kfaNFwnHfpV-7WPhg=",
    "p": ["rsa", 
        1223782426369497670965103140822422255529199101281048
        2177920357869418289771569269718078632784332720997458
        8179729985336687220073096675483822073402642772681280
        6169761045461725532947542701830356291600966444874604
        7222690146365929829513494105672895833281526138839216
        2051040350819406566563967272795487285560945461681, 
        65537],
} ]]></artwork>
        </figure>
      </section>

      <section title="AuthenticatedData">
        <t>In this object the content is authenticated with a MAC under a
        randomly-generated key (AuthenticatedData Key above), wrapped using
        the key encryption key above, identified by the above key tag.</t>

        <figure>
          <artwork><![CDATA[{
    "v": 1
    "t": "a",
    "c": "QXR0YWNrIGF0IGRhd24h",
    "a": "hmac-sha1",
    "m": "WT8ntFec5pbxj2seFTGsMGyFkXQ=",
    "k": [{
        "a": "aes",
        "i": "AfR60EnouBsF8yglqYjNUhLOeB4=",
        "k": "43QH-BFRSIsMSjQgCT1fLxZttMNJxCw776y4M3BnRCVklH
              g-PTozVw==",
        "t": "s"
    }],
} ]]></artwork>
        </figure>
      </section>

      <section title="EncryptedData">
        <t>In this object, the content is encrypted under the general AEAD
        algorithm using AES-128-CBC for encryption and HMAC-SHA1 for
        authentication. The keys are described above as "EncryptedData Key
        (E)" and "EncryptedData Key (A)", respectively. The temporary keys are
        wrapped using the PKCS#1 wrapping, under the RSA key pair above.</t>

        <figure>
          <artwork><![CDATA[{
    "v": 1
    "t": "e",
    "c": "ztt4s1A9zU73L7iaibiICeDpuiP0ovfw3ICI4-qqX11hbzG3",
    "ea": ["aead-gen", "aes128-cbc", "hmac-sha1",
    {
        "iv": "gPOe6qFL5W7Mhg9ODBLoZg==",
        "n": "0rlhQLrieXchGYbnxxkySg=="
    }],
    "k": [{
        "a": "pkcs1",
        "p": ["rsa", 122378242636949767096510314082242225552
            919910128104821779203578694182897715692697180786
            327843327209974588179729985336687220073096675483
            822073402642772681280616976104546172553294754270
            183035629160096644487460472226901463659298295134
            941056728958332815261388392162051040350819406566
            563967272795487285560945461681, 
            65537],
        "k": "kyUzZZJPFT8tfbUVgWScWoCkMhsMPI2IiBV7HgYy92rSLG
            BrTqpq8hGvwn0Arf-Qon3CxN345J2M4eGt56-NIyysKhusdN
            ogqKRMOK1wTIp3SJIj5xDuzJmQhAzMfFm-Y9_L0-4aafEfTG
            t9JNJwcjcYdnlJpI39cgAYNKcY4oQ=",
        "t": "p"
    }],
}]]></artwork>
        </figure>
      </section>
    </section>

    <section title="Mapping to CMS">
      <t>[[ SignedData == SignedData, AuthenticatedData == AuthenticatedData,
      EncryptedData == AuthEnvelopedData ]]</t>

      <t>[[ AlgorithmIdentifier == AlgorithmIdentifier ]]</t>

      <t>[[ PublicKey == SubjectPublicKeyInfo. In the latter case, equivalent
      to SKId+self-signed ]]</t>

      <t>[[ WrappedSymmetricKey == RecipientInfo ]]</t>
    </section>

    <section anchor="sec.version" title="Version Processing">
      <t>For the moment, all version numbers in the protocol MUST be 1.0.
      Receivers MUST return an error for any other version number. More
      interesting version processing will be defined in the future.</t>
    </section>

    <section anchor="sec.iana-cons" title="IANA Considerations">
      <t>[TODO] <list style="symbols">
          <t>Register MIME types</t>

          <t>Registries for algorithms</t>
        </list></t>
    </section>

    <section anchor="sec.sec-cons" title="Security Considerations">
      <t>Much more to follow here.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &rfc2045;

      &rfc2119;

      &rfc3339;

      &rfc3447;

      &rfc4086;

      &rfc4627;

      &rfc4648;

      &rfc5116;

      &rfc5246;

      &rfc5280;

      &rfc5649;

      &jsonschema;

      <reference anchor="FIPS-180-3">
        <front>
          <title>Secure Hash Standard (SHS)</title>

          <author>
            <organization>National Institute of Standards and Technology
            (NIST)</organization>
          </author>

          <date month="October" year="2008"/>
        </front>

        <seriesInfo name="FIPS" value="PUB 180-3"/>
      </reference>
    </references>

    <references title="Informative References">
      &rfc3986;

      &webfinger;

      &rfc5652;

      <reference anchor="krawczyk-ate">
        <front>
          <title>The Order of Encryption and Authentication for Protecting
          Communications (or: How Secure Is SSL?)</title>

          <author fullname="Hugo Krawczyk" initials="H." surname="Krawczyk"/>
        </front>

        <seriesInfo name="Advances in cryptology--CRYPTO 2001"
                    value="August 2001"/>
      </reference>

      <reference anchor="GCM">
        <front>
          <title>Recommendation for Block Cipher Modes of Operation:
          Galois/Counter Mode (GCM) and GMAC</title>

          <author>
            <organization>National Institute of Standards and Technology
            (NIST)</organization>
          </author>

          <date month="November" year="2007"/>
        </front>

        <seriesInfo name="SP" value="800-38D"/>
      </reference>
    </references>

    <section title="Acknowledgments">
      <t>[TODO]</t>
    </section>
  </back>
</rfc>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:nil
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
